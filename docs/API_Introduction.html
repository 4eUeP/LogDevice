<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Client library API · LogDevice</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## API basics"/><meta name="docsearch:version" content="2.46.5"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Client library API · LogDevice"/><meta property="og:type" content="website"/><meta property="og:url" content="https://logdevice.io/index.html"/><meta property="og:description" content="## API basics"/><meta property="og:image" content="https://logdevice.io/img/logdevice_og.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://logdevice.io/img/logdevice.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css"/><link rel="alternate" type="application/atom+xml" href="https://logdevice.io/blog/atom.xml" title="LogDevice Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://logdevice.io/blog/feed.xml" title="LogDevice Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-137238014-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/facebook_logdevice_whitewordmark.png" alt="LogDevice"/></a><a href="/versions.html"><h3>2.46.5</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/Overview.html" target="_self">Docs</a></li><li class=""><a href="/api/annotated.html" target="_self">API</a></li><li class=""><a href="/help.html" target="_self">Support</a></li><li class=""><a href="https://github.com/facebookincubator/LogDevice" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>API</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Getting started<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/Overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/LocalCluster.html">Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/Concepts.html">Architecture</a></li><li class="navListItem"><a class="navItem" href="/docs/Installation.html">Build LogDevice</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Configuration<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/FirstCluster.html">Creating your first cluster</a></li><li class="navListItem"><a class="navItem" href="/docs/Config.html">Cluster configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/Settings.html">Settings</a></li><li class="navListItem"><a class="navItem" href="/docs/Logs.html">Log configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Administration<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/LDShell.html">LogDevice Shell</a></li><li class="navListItem"><a class="navItem" href="/docs/LDQuery.html">LDQuery</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Concepts<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/Writepath.html">Write path</a></li><li class="navListItem"><a class="navItem" href="/docs/ReadPath.html">Read path</a></li><li class="navListItem"><a class="navItem" href="/docs/Consensus.html">Distributed consensus</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Designs<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/FailureDetection.html">Failure detection</a></li><li class="navListItem"><a class="navItem" href="/docs/Replication.html">Log replication configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/Recovery.html">Recovery after the failure of a sequencer</a></li><li class="navListItem"><a class="navItem" href="/docs/TrafficShaping.html">Traffic shaping</a></li><li class="navListItem"><a class="navItem" href="/docs/Rebuilding.html">Rebuilding</a></li><li class="navListItem"><a class="navItem" href="/docs/LogsDB.html">LogsDB</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">API<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/docs/API_Introduction.html">Client library API</a></li><li class="navListItem"><a class="navItem" href="/docs/API_Doxygen.html">Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Extending LogDevice<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/WritingPlugins.html">Writing plugins</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Client library API</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="api-basics"></a><a href="#api-basics" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>API basics</h2>
<p>To communicate with a LogDevice cluster, use the C++ client library.</p>
<h3><a class="anchor" aria-hidden="true" id="client-class"></a><a href="#client-class" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>Client</code> class</h3>
<p>To interact with a LogDevice cluster, create an instance of the <code>logdevice::Client</code> class.
A <code>logdevice::Client</code> object represents a connection to a specific LogDevice cluster.
Some of the actions that you can take with a <code>Client</code> object are:</p>
<ul>
<li>Appending records to logs.</li>
<li>Creating <code>logdevice::Reader</code> objects that are used to read records from logs.</li>
<li>Mapping timestamps (which are required record attributes) to the sequence number (LSN) of the
closest record in the log.</li>
<li>Trimming logs all the way to a specified LSN.</li>
</ul>
<p>You only need one instance of the class in order to interact with the cluster. It
will spawn several worker threads to enable it to scale. All <code>Client</code> methods are thread-safe.</p>
<p>Create a <code>Client</code> using a <code>ClientFactory</code>.</p>
<pre><code class="hljs css language-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;logdevice/include/Client.h&gt;</span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;facebook::logdevice::<span class="hljs-built_in">Client</span>&gt; client =
    facebook::logdevice::ClientFactory().create(
      <span class="hljs-comment">// path to the config file</span>
      <span class="hljs-string">"zk:10.0.0.1:2181,10.0.0.2:2181,10.0.0.3:2181/logdevice_test.conf"</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="synchronous-vs-asynchronous-api"></a><a href="#synchronous-vs-asynchronous-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Synchronous vs. asynchronous API</h3>
<p>Most <code>Client</code> API methods are available in synchronous or asynchronous flavors.
Generally speaking, using the asynchronous methods scales better, as you can schedule many
outstanding requests to LogDevice without blocking your threads of execution.</p>
<p>If you use asynchronous methods, keep in mind that:</p>
<ul>
<li>The given callback functions are called on an unspecified LogDevice
client worker thread.</li>
<li>The callback function has to complete quickly. If it takes a long time to
complete, it will block the LogDevice client worker thread, which may delay the
execution of any other pending requests.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="lsn"></a><a href="#lsn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LSN</h3>
<p>The log sequence number, or LSN, is the combination of the <em>epoch</em> and the <em>epoch sequence number</em>. It is guaranteed to be monotonically increasing.</p>
<p>Each record has an LSN, but it may not be unique, because records that are batched (due to BufferedWriter or sequencer batching) all get the same LSN. For those records, you can use the (LSN, batch_offset) combination to distinguish between them.</p>
<h2><a class="anchor" aria-hidden="true" id="writing-records"></a><a href="#writing-records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing Records</h2>
<p>When writing to the cluster, you can optimize for latency or for throughput.
<code>Client::append()</code> sends the record to the cluster immediately, and each record is assigned its own LSN.
Because there is a cost to process each append inside LogDevice,
sending many small records limits throughput.
Unless you definitely do not want LogDevice to perform batching, or if you want
to have the lowest latency possible, use <code>BufferedWriter::append()</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="buffered-writes-for-higher-throughput-preferred"></a><a href="#buffered-writes-for-higher-throughput-preferred" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Buffered writes for higher throughput (Preferred)</h3>
<p><code>BufferedWriter</code> maintains buffers of unsent writes for each log on the client.
It sends each batch of writes to LogDevice to be stored as one larger record with one LSN.
A batch is sent to the cluster when the time since starting the current batch, or the number of bytes in the batch, exceeds a threshold.
The records are automatically decoded on the read path by the <code>Reader</code> or <code>AsyncReader</code> object.</p>
<p>When the append of each batch of data is completed, the application is notified via a callback
interface.
Because BufferedWriter is meant for high-throughput writing, the callback interface
does not use <code>std::function</code>.
Instead, when you create the BufferedWriter object, you pass it a single subclass of <code>AppendCallback</code>.</p>
<p>You can, optionally, pass a pointer to a piece of context with each append call.
This context is returned on the callback in the <code>ContextSet</code> vector.
Some applications use this context to include state or tracking information for each record.</p>
<pre><code class="hljs css language-c++"><span class="hljs-comment">// this class is called when the cluster reports the status of the append</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedWriterCallback</span> :</span> <span class="hljs-keyword">public</span> BufferedWriter::AppendCallback {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(<span class="hljs-keyword">logid_t</span> <span class="hljs-comment">/* unused */</span>,
                 ContextSet contexts,
                 <span class="hljs-keyword">const</span> DataRecordAttributes&amp; <span class="hljs-comment">/* unused */</span>)</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"BufferedWriterCallback: a batch of "</span> &lt;&lt; contexts.<span class="hljs-built_in">size</span>()
              &lt;&lt; <span class="hljs-string">" records successfully written ."</span> &lt;&lt; <span class="hljs-string">'\n'</span>;
    }

  <span class="hljs-comment">// BufferedWriter exhausted all retries it was configured to do.</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(<span class="hljs-keyword">logid_t</span> log_id, ContextSet contexts, Status status)</span> <span class="hljs-keyword">override</span> </span>{

    <span class="hljs-comment">// Handle the error if needed. For example, collect the</span>
    <span class="hljs-comment">// failed payloads to retry them later.</span>
    <span class="hljs-comment">/*
    std::lock_guard&lt;std::mutex&gt; guard(mutex);
    for (auto&amp; ctx : contexts) {
      payloadsFailed.push_back(std::move(ctx.second));
      }
      */</span>
    }
    <span class="hljs-comment">// ...</span>
};

facebook::<span class="hljs-function">logdevice::<span class="hljs-keyword">logid_t</span> <span class="hljs-title">logid</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;
facebook::logdevice::BufferedWriter::Options options;
BufferedWriterCallback cb;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;facebook::logdevice::BufferedWriter&gt; buffered_writer;
buffered_writer = facebook::logdevice::BufferedWriter::create(client, &amp;cb, options);

<span class="hljs-keyword">int</span> buffered = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> record_idx = <span class="hljs-number">0</span>; record_idx &lt; <span class="hljs-number">15000</span>; ++record_idx) {
  <span class="hljs-keyword">int</span> error = buffered_writer-&gt;append(
      logid,
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"payload "</span> + <span class="hljs-built_in">std</span>::to_string(record_idx)),
      <span class="hljs-comment">/* context */</span> <span class="hljs-literal">nullptr</span>);
  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-comment">// Insert error handling. For example, try again at least once.</span>
    <span class="hljs-comment">// Payload remains in std::string.</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"BufferedWriter-&gt;append() failed. "</span>
              &lt;&lt; facebook::logdevice::error_description(
                     facebook::logdevice::err)
              &lt;&lt; <span class="hljs-string">'\n'</span>;
  } <span class="hljs-keyword">else</span> {
    ++buffered;
  }
}

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lifetime-of-payloads"></a><a href="#lifetime-of-payloads" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lifetime of payloads</h3>
<p>To avoid copying payloads too much, BufferedWriter takes advantage of
std::string's move constructor. BufferedWriter::append() takes the payload as
<code>std::string&amp;&amp;</code> and moves it into BufferedWriter.
When it calls the append callback, BufferedWriter doesn't need the payloads anymore.
It passes payloads to the callback, and your application can steal those strings.
If <code>destroy_payloads</code> is set to true, BufferedWriter destroys the payloads as soon as they're not needed.</p>
<h3><a class="anchor" aria-hidden="true" id="bufferedwriter-options"></a><a href="#bufferedwriter-options" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BufferedWriter options</h3>
<p>As you make a series of asynchronous appends, one or more might fail.
If you need the records to be written in order, set the <code>mode</code> option so that LogDevice waits for each batch
to be appended successfully before sending the next batch.</p>
<pre><code class="hljs css language-c++"><span class="hljs-comment">// Only allow one batch at a time to be inflight to LogDevice servers.</span>
options.mode = BufferedWriter::Options::Mode::ONE_AT_A_TIME;
</code></pre>
<p>Be sure to set a time- or memory-based trigger.
The default time trigger is infinity.
The default size trigger is the maximum allowed record size (max-payload-size setting).</p>
<pre><code class="hljs css language-c++"><span class="hljs-comment">// Writes for this log are flushed once the oldest has been</span>
<span class="hljs-comment">// buffered for 1000 ms</span>
options.time_trigger = <span class="hljs-built_in">std</span>::chrono::milliseconds(<span class="hljs-number">1000</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="bufferedwriter-example"></a><a href="#bufferedwriter-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BufferedWriter example</h3>
<p>See <code>examples/buffered_writer.cpp</code> in the source tree for an example of how to
use the <code>BufferedWriter</code> API.</p>
<h3><a class="anchor" aria-hidden="true" id="unbatched-writes"></a><a href="#unbatched-writes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unbatched writes</h3>
<p>To write data with the lowest possible latency, call <code>append()</code> on the <code>Client</code> instance,
passing a std::function callback.
The callback is invoked when the append completes, whether it is successful or not.</p>
<pre><code class="hljs css language-c++">
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append_callback</span><span class="hljs-params">(facebook::logdevice::Status st,
             <span class="hljs-keyword">const</span> facebook::logdevice::DataRecord&amp; r)</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Append result: "</span>;
  <span class="hljs-keyword">if</span> (st == facebook::logdevice::E::OK){
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"succeeded, record appended to log "</span> &lt;&lt; r.logid.val()
              &lt;&lt; <span class="hljs-string">", LSN "</span> &lt;&lt; facebook::logdevice::lsn_to_string(r.attrs.lsn);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"failed with error: "</span>
              &lt;&lt; facebook::logdevice::error_description(st);
  }
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
<span class="hljs-comment">// ...</span>

facebook::<span class="hljs-function">logdevice::<span class="hljs-keyword">logid_t</span> <span class="hljs-title">logid</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">payload</span><span class="hljs-params">(<span class="hljs-string">"data"</span>)</span></span>;

<span class="hljs-keyword">int</span> rv = client-&gt;append(logid, payload, &amp;append_callback);
<span class="hljs-keyword">if</span> (rv != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to enqueue append to log "</span> &lt;&lt; logid.val() &lt;&lt; <span class="hljs-string">": "</span>
      &lt;&lt; facebook::logdevice::error_description(facebook::logdevice::err);
}
</code></pre>
<p>Each record in this writing flow is assigned a unique sequence number (LSN).</p>
<p>See <code>examples/write.cpp</code> in the source tree for a complete example of how to use the <code>append()</code> API.</p>
<h2><a class="anchor" aria-hidden="true" id="reading-from-logdevice"></a><a href="#reading-from-logdevice" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading from LogDevice</h2>
<p>The read API implemented by the <code>logdevice::Reader</code> and <code>logdevice::AsyncReader</code> classes follows the non-durable
subscription model. A single <code>Reader</code> or <code>AsyncReader</code> object can be used to create and manage
multiple read streams. Those are roughly equivalent to POSIX file descriptors —
read points in a specific file.</p>
<p>The difference between the <code>logdevice</code>
and POSIX read models is that the <code>read()</code> method returns records for
all active read streams on that <code>Reader</code> or <code>AsyncReader</code> object, which often belong to many
different logs. The records are passed to the application as they arrive from
the LogDevice cluster and become available. In contrast, the POSIX <code>read()</code>
call on a file descriptor returns data from that one file only.</p>
<p>In addition to records, the <code>read()</code> method may also report a number of
gaps. A gap describes a range of LSNs with some sort of an exceptional
condition. Common gap types include:</p>
<ul>
<li>TRIM - records in the range are older than
the trim point.</li>
<li>BRIDGE - a bridge that completes an epoch. This could be the result of a sequencer failover or log reconfiguration, but no data was lost.</li>
<li>DATALOSS - records in the range appear to be permanently lost.</li>
<li>ACCESS - the reader does not have permissions to read the log.</li>
</ul>
<p>The <code>Reader::stopReading()</code> method may be used to indicate that the client is no
longer interested in receiving records for the specified log.</p>
<p>If you prefer to stream records rather than pulling them, define a
callback to be called for each record or gap, and use the
<code>AsyncReader</code> class instead.</p>
<p>LogDevice does not offer durable read pointers. Log
readers that want to retain their position in the log, so that they can resume
reading after a crash or restart, should periodically save the LSN of the last
record they read in a persistent key-value store.</p>
<h3><a class="anchor" aria-hidden="true" id="reading-using-the-reader-class"></a><a href="#reading-using-the-reader-class" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading using the <code>Reader</code> class</h3>
<p>To read from LogDevice using the <code>Reader</code> class:</p>
<ol>
<li>Create a <code>Reader</code> instance by calling the <code>createReader()</code> method on the
<code>Client</code> instance.</li>
<li>Call <code>startReading()</code> on it for each log.</li>
<li>Call the <code>read()</code> method on the reader whenever your application is ready to
consume records.</li>
</ol>
<p>Check out <code>examples/tail.cpp</code> and <code>examples/cat.cpp</code> in the source tree for sample code.</p>
<h3><a class="anchor" aria-hidden="true" id="reading-using-the-asyncreader-class"></a><a href="#reading-using-the-asyncreader-class" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading using the <code>AsyncReader</code> class</h3>
<p><code>AsyncReader</code> allows you to register callbacks for each record/gap received, as
well as a callback for when the <code>until_lsn</code> has been reached.</p>
<p>Example:</p>
<pre><code class="hljs css language-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;logdevice/include/AsyncReader.h&gt;</span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recordCallback</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;facebook::logdevice::DataRecord&gt;&amp; record)</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Received record for log "</span> &lt;&lt; record-&gt;logid.val() &lt;&lt; <span class="hljs-string">": LSN "</span>
      &lt;&lt; facebook::logdevice::lsn_to_string(record-&gt;attrs.lsn)
      &lt;&lt; <span class="hljs-string">", payload \""</span> &lt;&lt; record-&gt;payload.toString() &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">gapCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> facebook::logdevice::GapRecord&amp; gap)</span> </span>{
  <span class="hljs-keyword">using</span> facebook::logdevice::GapType;
  <span class="hljs-keyword">switch</span> (gap.type) {
    <span class="hljs-keyword">case</span> GapType::BRIDGE:
    <span class="hljs-keyword">case</span> GapType::HOLE:
    <span class="hljs-keyword">case</span> GapType::TRIM:
    <span class="hljs-keyword">case</span> GapType::FILTERED_OUT:
      <span class="hljs-comment">// benign gaps in LSN numbering sequence</span>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> GapType::DATALOSS:
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error! Data has been lost for log "</span> &lt;&lt; gap.logid.val()
          &lt;&lt; <span class="hljs-string">" from LSN "</span> &lt;&lt; facebook::logdevice::lsn_to_string(gap.lo)
          &lt;&lt; <span class="hljs-string">" to LSN "</span> &lt;&lt; facebook::logdevice::lsn_to_string(gap.hi)
          &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> GapType::ACCESS:
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error! Access denied to log "</span> &lt;&lt; gap.logid.val()
          &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> GapType::NOTINCONFIG:
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error! Log "</span> &lt;&lt; gap.logid.val() &lt;&lt; <span class="hljs-string">" not found!"</span>
          &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Unrecognized gap of type "</span>
          &lt;&lt; facebook::logdevice::gapTypeToString(gap.type) &lt;&lt; <span class="hljs-string">" for log "</span>
          &lt;&lt; gap.logid.val() &lt;&lt; <span class="hljs-string">" from LSN "</span>
          &lt;&lt; facebook::logdevice::lsn_to_string(gap.lo) &lt;&lt; <span class="hljs-string">" to LSN "</span>
          &lt;&lt; facebook::logdevice::lsn_to_string(gap.hi) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
      <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doneCallback</span><span class="hljs-params">(facebook::logdevice::<span class="hljs-keyword">logid_t</span> log_id)</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Finished reading log_id "</span> &lt;&lt; log_id.val() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;facebook::logdevice::AsyncReader&gt; reader =
    client-&gt;createAsyncReader();
reader-&gt;setRecordCallback(recordCallback);
reader-&gt;setGapCallback(gapCallback);
reader-&gt;setDoneCallback(doneCallback);

facebook::<span class="hljs-function">logdevice::<span class="hljs-keyword">logid_t</span> <span class="hljs-title">logid</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;
facebook::logdevice::<span class="hljs-keyword">lsn_t</span> from_lsn = facebook::logdevice::LSN_OLDEST;

<span class="hljs-keyword">int</span> rv = reader-&gt;startReading(logid, from_lsn);
<span class="hljs-keyword">if</span> (rv != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error! Couldn't start reading: "</span>
      &lt;&lt; facebook::logdevice::error_description(facebook::logdevice::err)
      &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="discovering-positions-to-read"></a><a href="#discovering-positions-to-read" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Discovering positions to read</h2>
<p>As LogDevice doesn't store read pointers for clients, the clients have to
specify explicit <code>start</code> and <code>until</code> LSNs when reading. There are several
ways to discover the LSNs of interest.</p>
<h3><a class="anchor" aria-hidden="true" id="maximum-bound-values"></a><a href="#maximum-bound-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Maximum bound values</h3>
<p>Specify <code>facebook::logdevice::LSN_OLDEST</code> as the <code>start_lsn</code> to start
reading from the first possible LSN.</p>
<p>Specify <code>facebook::logdevice::LSN_MAX</code> as the <code>until_lsn</code> to read indefinitely.
New records will be read as they are appended to the
tail and released.</p>
<p>Specify both of these values to cover the entire possible LSN space for a log.</p>
<h3><a class="anchor" aria-hidden="true" id="checkpointed-values"></a><a href="#checkpointed-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Checkpointed values</h3>
<p>If your reader saves checkpoints (LSNs) somewhere based on records it has
already seen, these checkpoints can be used to restart reading from the same
point.</p>
<h3><a class="anchor" aria-hidden="true" id="lsn-based-on-append-timestamp"></a><a href="#lsn-based-on-append-timestamp" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LSN based on append timestamp</h3>
<p>A typical way to use LogDevice is to start reading from a certain timestamp.
To discover which LSN corresponds to that timestamp, use the <code>findTime()</code> API call:</p>
<pre><code class="hljs css language-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findTimeCallback</span><span class="hljs-params">(facebook::logdevice::Status st,
                   facebook::logdevice::<span class="hljs-keyword">lsn_t</span> result)</span> </span>{
  <span class="hljs-keyword">if</span> (st == facebook::logdevice::Status::OK) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Received findtime result: "</span>
              &lt;&lt; facebook::logdevice::lsn_to_string(result) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error returned by findtime: "</span>
              &lt;&lt; facebook::logdevice::error_description(st) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  }
}

facebook::<span class="hljs-function">logdevice::<span class="hljs-keyword">logid_t</span> <span class="hljs-title">logid</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;
<span class="hljs-comment">// Find LSN for records written 30 seconds ago</span>
<span class="hljs-built_in">std</span>::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">timestamp</span><span class="hljs-params">(
 <span class="hljs-built_in">std</span>::chrono::duration_cast&lt;<span class="hljs-built_in">std</span>::chrono::milliseconds&gt;(
   <span class="hljs-built_in">std</span>::chrono::system_clock::now().time_since_epoch() -
       <span class="hljs-built_in">std</span>::chrono::seconds(<span class="hljs-number">30</span>)))</span></span>;
<span class="hljs-keyword">int</span> rv = client-&gt;findTime(logid, timestamp, findTimeCallback);
<span class="hljs-keyword">if</span> (rv != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Couldn't run findtime: "</span>
      &lt;&lt; facebook::logdevice::error_description(facebook::logdevice::err)
      &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}

</code></pre>
<p><strong>Note:</strong> this feature assumes that clocks between all sequencer nodes in a
LogDevice cluster are in sync. If the clocks on machines in your cluster diverge
by a lot, the results of <code>findTime()</code> calls may be inconsistent.</p>
<h3><a class="anchor" aria-hidden="true" id="current-tail-lsn"></a><a href="#current-tail-lsn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Current tail LSN</h3>
<p>To start or stop reading at the tail of the log, determine the LSN of the last record using the <code>getTailLSN()</code> method.</p>
<pre><code class="hljs css language-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tailLSNCallback</span><span class="hljs-params">(facebook::logdevice::Status st,
                  facebook::logdevice::<span class="hljs-keyword">lsn_t</span> result)</span> </span>{
  <span class="hljs-keyword">if</span> (st == facebook::logdevice::Status::OK) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Received tail LSN: "</span>
              &lt;&lt; facebook::logdevice::lsn_to_string(result) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error fetching tail LSN: "</span>
              &lt;&lt; facebook::logdevice::error_description(st) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  }
}

facebook::<span class="hljs-function">logdevice::<span class="hljs-keyword">logid_t</span> <span class="hljs-title">logid</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;
<span class="hljs-keyword">int</span> rv = client-&gt;getTailLSN(logid, tailLSNCallback);
<span class="hljs-keyword">if</span> (rv != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Couldn't run getTailLSN(): "</span>
            &lt;&lt; facebook::logdevice::error_description(facebook::logdevice::err)
            &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}

</code></pre>
<h2><a class="anchor" aria-hidden="true" id="trimming-data-from-logs"></a><a href="#trimming-data-from-logs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Trimming data from logs</h2>
<p>You can configure LogDevice to trim data automatically:</p>
<ul>
<li>Based on time (see <code>backlog</code> attribute in <a href="/docs/Logs.html">log configuration</a>).</li>
<li>Based on available storage space (see <code>rocksdb-free-disk-space-threshold-low</code> and
<code>sbr-node-threshold</code> in <a href="/docs/Settings.html">settings</a>).</li>
</ul>
<p>A client can also trim data explicitly. See the <code>trim()</code> and <code>trimSync()</code> methods in
the <code>Client</code> class.</p>
<h2><a class="anchor" aria-hidden="true" id="running-the-samples"></a><a href="#running-the-samples" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Running the samples</h2>
<p>To run the samples, follow the instructions in <a href="/docs/LocalCluster.html">Running a local cluster</a>
to start a local cluster. Next, create a log range using <code>ldshell logs create</code>.
Run the sample with <code>--help</code> to make it display a list of its options.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/LogsDB.html"><span class="arrow-prev">← </span><span class="function-name-prevnext">LogsDB</span></a><a class="docs-next button" href="/docs/API_Doxygen.html"><span>Reference</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#api-basics">API basics</a><ul class="toc-headings"><li><a href="#client-class"><code>Client</code> class</a></li><li><a href="#synchronous-vs-asynchronous-api">Synchronous vs. asynchronous API</a></li><li><a href="#lsn">LSN</a></li></ul></li><li><a href="#writing-records">Writing Records</a><ul class="toc-headings"><li><a href="#buffered-writes-for-higher-throughput-preferred">Buffered writes for higher throughput (Preferred)</a></li><li><a href="#lifetime-of-payloads">Lifetime of payloads</a></li><li><a href="#bufferedwriter-options">BufferedWriter options</a></li><li><a href="#bufferedwriter-example">BufferedWriter example</a></li><li><a href="#unbatched-writes">Unbatched writes</a></li></ul></li><li><a href="#reading-from-logdevice">Reading from LogDevice</a><ul class="toc-headings"><li><a href="#reading-using-the-reader-class">Reading using the <code>Reader</code> class</a></li><li><a href="#reading-using-the-asyncreader-class">Reading using the <code>AsyncReader</code> class</a></li></ul></li><li><a href="#discovering-positions-to-read">Discovering positions to read</a><ul class="toc-headings"><li><a href="#maximum-bound-values">Maximum bound values</a></li><li><a href="#checkpointed-values">Checkpointed values</a></li><li><a href="#lsn-based-on-append-timestamp">LSN based on append timestamp</a></li><li><a href="#current-tail-lsn">Current tail LSN</a></li></ul></li><li><a href="#trimming-data-from-logs">Trimming data from logs</a></li><li><a href="#running-the-samples">Running the samples</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/logdevice.svg" alt="LogDevice" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/Overview.html">Getting Started</a><a href="/docs/FirstCluster.html">Creating your first cluster</a><a href="/api/annotated.html">C++ API Reference</a></div><div><h5>Community</h5><a href="https://facebook.com/groups/logdevice.oss/">LogDevice Users Group</a><a href="http://stackoverflow.com/questions/tagged/logdevice" target="_blank" rel="noreferrer noopener">Stack Overflow</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/facebookincubator/LogDevice">GitHub</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Facebook</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'f0ece773627cb7003a57c0edd6ec7dd8',
                indexName: 'logdevice',
                inputSelector: '#search_input_react'
              });
            </script></body></html>