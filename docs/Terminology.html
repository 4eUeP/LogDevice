<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Terminology · LogDevice</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;&lt;em&gt;acknowledge (a record).&lt;/em&gt; A record is acknowledged to the writer when it is durably stored, according to the replication policy for that log.&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Terminology · LogDevice"/><meta property="og:type" content="website"/><meta property="og:url" content="https://logdevice.io/index.html"/><meta property="og:description" content="&lt;p&gt;&lt;em&gt;acknowledge (a record).&lt;/em&gt; A record is acknowledged to the writer when it is durably stored, according to the replication policy for that log.&lt;/p&gt;
"/><meta property="og:image" content="https://logdevice.io/img/logdevice_og.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://logdevice.io/img/logdevice.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://logdevice.io/blog/atom.xml" title="LogDevice Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://logdevice.io/blog/feed.xml" title="LogDevice Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-137238014-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/facebook_logdevice_whitewordmark.png" alt="LogDevice"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/Overview.html" target="_self">Docs</a></li><li class=""><a href="/api/annotated.html" target="_self">API</a></li><li class=""><a href="/help.html" target="_self">Support</a></li><li class=""><a href="https://github.com/facebookincubator/LogDevice" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Getting started</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/Overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/LocalCluster.html">Run a local cluster in Docker</a></li><li class="navListItem"><a class="navItem" href="/docs/Concepts.html">Concepts and architecture</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/Terminology.html">Terminology</a></li><li class="navListItem"><a class="navItem" href="/docs/Installation.html">Build LogDevice</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Configuration</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/FirstCluster.html">Creating your first cluster</a></li><li class="navListItem"><a class="navItem" href="/docs/Config.html">Cluster configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/Settings.html">Settings</a></li><li class="navListItem"><a class="navItem" href="/docs/Logs.html">Log configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Administration</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/LDShell.html">LogDevice Shell</a></li><li class="navListItem"><a class="navItem" href="/docs/LDQuery.html">LDQuery</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/API_Introduction.html">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/API_Doxygen.html">Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extending LogDevice</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/WritingPlugins.html">Writing plugins</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Terminology</h1></header><article><div><span><p><em>acknowledge (a record).</em> A record is acknowledged to the writer when it is durably stored, according to the replication policy for that log.</p>
<p><em>ALL_SEND_ALL.</em> A fallback mode for the read path where each storage node sends all records. It's less efficient than single-copy delivery (SCD), but better for detecting gaps.</p>
<p><em>appender.</em> An in-memory object that makes sure a record is durably written to a copyset.</p>
<p><em>authoritative status</em> The authoritative status of a shard indicates what role this shard is playing in the replication of data records.</p>
<p><em>bridge gap.</em> On the read path, a bridge gap indicates that there are no records stored between two LSNs across 2 epochs. It indicates a benign gap, not a gap due to data loss.</p>
<p><em>bridge record.</em> On the storage layer, a record that represents a bridge gap.</p>
<p><em>compaction.</em> The process of combining multiple SST files into a single SST file to improve efficiency. Records that are older than their retention period may be removed during this process. Compaction occurs on a schedule. It may also be started by LogDevice as part of rebuilding.</p>
<p><em>copyset.</em> The set of nodes on which a given record is actually stored.</p>
<p><em>dataloss gap.</em> A gap between two sequence numbers that indicates that records were lost.</p>
<p><em>delta log.</em> See <em>snapshot</em>.</p>
<p><em>disaggregated cluster.</em> A cluster in which there are two types of hardware, where one type only handles the sequencing of records, and the other type stores records. These are referred to as sequencer and storage nodes, respectively.</p>
<p><em>donor.</em> During rebuilding, the shard from which the record is being copied.</p>
<p><em>draining (of storage nodes).</em> Storage nodes are drained when LogDevice intends to remove nodes from the cluster either temporarily (such as for maintenance) or indefinitely (for example, to shrink a cluster). No data is written to a node that is draining.</p>
<p><em>draining (of a sequencer).</em> The sequencer stops accepting new appends but waits for all appenders in its sliding window to finish their replication and retire.</p>
<p><em>durability.</em> Data has been stored, redundantly, so that it is not lost or compromised.</p>
<p><em>epoch.</em> The upper 32 bits of the log sequence number (LSN).</p>
<p><em>ESN (epoch sequence number).</em> The lower 32 bits of the log sequence number.</p>
<p><em>event log.</em> An internal log that tracks shard authoritative states and transitions (such as rebuilding).</p>
<p><em>f-majority.</em> A set of nodes that intersects every possible copyset. If a reader cannot find a particular record on an f-majority of nodes, then that record must be under-replicated or lost.</p>
<p><em>findtime.</em> A kind of query to a LogDevice cluster that, given a timestamp, returns an LSN that approximately corresponds to that time.</p>
<p><em>gap record.</em> A special kind of record that indicates there is no data at this LSN. Types include bridge, dataloss, and hole plug.</p>
<p><em>gossip.</em> The protocol that nodes follow to contact each other for their status to arrive at a consensus view of the cluster.</p>
<p><em>historical nodeset.</em> When an epoch changes, the nodeset is permitted to change as well. Nodesets that belong to older epochs are called historical nodesets.</p>
<p><em>hole plug.</em> A special record indicating that there is no record with this LSN. No record was acknowledged with that sequence number. It indicates a benign gap, not a gap due to data loss.</p>
<p><em>internal log.</em> A LogDevice cluster uses one of its own logs to maintain some shared internal state.</p>
<p><em>L0 file.</em> A file used by RocksDB to store records. It's created when the in-memory tables are flushed to disk. Each RocksDB partition has a separate set of L0 files.</p>
<p><em>log.</em> A record-oriented, append-only, trimmable file. Once appended, a record is immutable. Each record is uniquely identified by a monotonically increasing sequence number. Readers read records sequentially from any point inside the retention period.</p>
<p><em>log ID.</em> Every log is identified by a numeric ID. Each log has a corresponding metadata log, which has an ID of 2^63 + log_id.</p>
<p><em>logsconfig.</em> A pair of internal logs (and a replicated state machine that corresponds to them) that stores the configuration for logs.</p>
<p><em>LSN (log sequence number).</em> A sequential ID used to order records in a log. The upper 32 bits are the epoch number, and the lower 32 are the offset within the epoch, or epoch sequence number (ESN). Normally, this number increases sequentially, but certain events, such as sequencer failover or changing replication settings, cause an &quot;epoch bump&quot;, in which the epoch is incremented and the ESN is reset. Often formatted as <code>eXXXnYYYY</code>, where <code>XXX</code> is the epoch and <code>YYYY</code> is the ESN.</p>
<p><em>metadata log.</em> Every log has an associated metadata log that records things like historical nodesets and replication constraints.</p>
<p><em>mini-rebuilding.</em> A rebuilding limited to a specified time range.</p>
<p><em>node.</em> Synonym for server or host. Each node runs an instance of the LogDevice server.</p>
<p><em>nodeset.</em> The set of disks that may have data for an epoch of a log. This is now known as a storage set, but this term is still used throughout LogDevice.</p>
<p><em>non-authoritative rebuilding.</em> If the number of shards that is down is more than the replication factor, it may not be possible to fully re-replicate all of the data records. When this happens, rebuilding is best effort, or non-authoritative. This may cause readers to stall if data is lost because some nodes remain unavailable. This requires a manual operation to unstall the readers and accept the data loss.</p>
<p><em>partial compaction.</em> When several small L0 files are compacted into a larger L0 file, leaving most L0 files alone. Partial compaction is triggered automatically when there is a size disparity between L0 files.</p>
<p><em>partition.</em> The database is made up of partitions. Each partition corresponds to a time range and contains all the record with timestamps that fall into that range. The typical length of that range is about 15 minutes and the data size in the partition is a few gigabytes. A new partition is created every few minutes to accommodate new data. Usually newly appended data is written to the latest partition, but all partitions are always writable. In particular, during rebuilding, many records are written to old partitions.</p>
<p>Reading works in two levels: at a higher level, the reader steps from partition to partition sequentially; at a lower level, it steps from record to record inside the partition until it reaches the end of partition.</p>
<p><em>rebuilding.</em> The process of re-replicating records after a storage failure.</p>
<p><em>record.</em> The smallest unit of data in a log. A record includes the log id, LSN, copyset, timestamp, and the payload.</p>
<p><em>recovery.</em> The process of guaranteeing sanity at the tail of an epoch after a sequencer failure.</p>
<p><em>release.</em> A record is released to the reader when it is durably stored and there are no in-flight records with a smaller LSN.</p>
<p><em>rewind.</em> If a client is reading in SCD mode and determines there may be a gap, it tells the storage nodes to rewind and fall back to ALL_SEND_ALL mode.</p>
<p><em>RSM (replicated state machine).</em> A state machine that tails a pair of internal logs to build a state that is eventually consistent across all hosts in the cluster.</p>
<p><em>SCD (single-copy delivery).</em> An optimization used in the read path. Only the primary node for the record reads and sends the record to the client.</p>
<p><em>sealing.</em> The first stage of recovery, in which the old epoch is fenced off to prevent any new writes happening to it.</p>
<p><em>sequencer.</em> An object responsible for assigning LSNs to incoming records. Can also refer to a node that can run sequencers.</p>
<p><em>shard.</em> A storage unit in a node.</p>
<p><em>snapshot.</em> Each internal log is really two logs: the delta log and the snapshot log. The delta stores recent changes, and every so often, the changes are accumulated into a snapshot and written to the snapshot log.</p>
<p><em>SST (Sorted Sequence Table) file.</em> Same as L0 file in RocksDB.</p>
<p><em>storage set.</em> The set of shards that contain all records in an epoch.</p>
<p><em>trim.</em> Delete older records in a log. Trimming can be retention-based, space-based, or on demand.</p>
<p><em>wave.</em> If the appender cannot successfully store a record in a copyset, it picks a new one and tries again. Each attempt is called a wave.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/Concepts.html"><span class="arrow-prev">← </span><span>Concepts and architecture</span></a><a class="docs-next button" href="/docs/Installation.html"><span class="function-name-prevnext">Build LogDevice</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/logdevice.svg" alt="LogDevice" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/Overview.html">Getting Started</a><a href="/docs/FirstCluster.html">Creating your first cluster</a><a href="/api/annotated.html">C++ API Reference</a></div><div><h5>Community</h5><a href="https://facebook.com/groups/logdevice.oss/">LogDevice Users Group</a><a href="http://stackoverflow.com/questions/tagged/logdevice" target="_blank" rel="noreferrer noopener">Stack Overflow</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/facebookincubator/LogDevice">GitHub</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2019 Facebook</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'f0ece773627cb7003a57c0edd6ec7dd8',
                indexName: 'logdevice',
                inputSelector: '#search_input_react'
              });
            </script></body></html>