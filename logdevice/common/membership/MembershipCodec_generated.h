// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MEMBERSHIPCODEC_FACEBOOK_LOGDEVICE_MEMBERSHIP_FLAT_BUFFER_CODEC_H_
#define FLATBUFFERS_GENERATED_MEMBERSHIPCODEC_FACEBOOK_LOGDEVICE_MEMBERSHIP_FLAT_BUFFER_CODEC_H_

#include "flatbuffers/flatbuffers.h"

namespace facebook { namespace logdevice { namespace membership {
namespace flat_buffer_codec {

struct ShardID;

struct ShardState;

struct StorageNodeState;

struct StorageMembership;

struct SequencerNodeState;

struct SequencerMembership;

///////////// StorageMembership ///////////////////
enum class StorageState : uint8_t {
  NONE = 0,
  NONE_TO_RO = 1,
  READ_ONLY = 2,
  READ_WRITE = 3,
  RW_TO_RO = 4,
  DATA_MIGRATION = 5,
  INVALID = 6,
  MIN = NONE,
  MAX = INVALID
};

inline const char** EnumNamesStorageState() {
  static const char* names[] = {"NONE",
                                "NONE_TO_RO",
                                "READ_ONLY",
                                "READ_WRITE",
                                "RW_TO_RO",
                                "DATA_MIGRATION",
                                "INVALID",
                                nullptr};
  return names;
}

inline const char* EnumNameStorageState(StorageState e) {
  return EnumNamesStorageState()[static_cast<int>(e)];
}

enum class MetaDataStorageState : uint8_t {
  NONE = 0,
  METADATA = 1,
  PROMOTING = 2,
  INVALID = 3,
  MIN = NONE,
  MAX = INVALID
};

inline const char** EnumNamesMetaDataStorageState() {
  static const char* names[] = {
      "NONE", "METADATA", "PROMOTING", "INVALID", nullptr};
  return names;
}

inline const char* EnumNameMetaDataStorageState(MetaDataStorageState e) {
  return EnumNamesMetaDataStorageState()[static_cast<int>(e)];
}

MANUALLY_ALIGNED_STRUCT(2) ShardID FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t node_idx_;
  uint16_t shard_idx_;

 public:
  ShardID() {
    memset(this, 0, sizeof(ShardID));
  }
  ShardID(const ShardID& _o) {
    memcpy(this, &_o, sizeof(ShardID));
  }
  ShardID(uint16_t _node_idx, uint16_t _shard_idx)
      : node_idx_(flatbuffers::EndianScalar(_node_idx)),
        shard_idx_(flatbuffers::EndianScalar(_shard_idx)) {}

  uint16_t node_idx() const {
    return flatbuffers::EndianScalar(node_idx_);
  }
  uint16_t shard_idx() const {
    return flatbuffers::EndianScalar(shard_idx_);
  }
};
STRUCT_END(ShardID, 4);

struct ShardState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHARD_IDX = 4,
    VT_STORAGE_STATE = 6,
    VT_FLAGS = 8,
    VT_METADATA_STATE = 10,
    VT_ACTIVE_MAINTENANCE = 12,
    VT_SINCE_VERSION = 14
  };
  uint16_t shard_idx() const {
    return GetField<uint16_t>(VT_SHARD_IDX, 0);
  }
  StorageState storage_state() const {
    return static_cast<StorageState>(GetField<uint8_t>(VT_STORAGE_STATE, 0));
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  MetaDataStorageState metadata_state() const {
    return static_cast<MetaDataStorageState>(
        GetField<uint8_t>(VT_METADATA_STATE, 0));
  }
  uint64_t active_maintenance() const {
    return GetField<uint64_t>(VT_ACTIVE_MAINTENANCE, 0);
  }
  uint64_t since_version() const {
    return GetField<uint64_t>(VT_SINCE_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
        VerifyField<uint16_t>(verifier, VT_SHARD_IDX) &&
        VerifyField<uint8_t>(verifier, VT_STORAGE_STATE) &&
        VerifyField<uint32_t>(verifier, VT_FLAGS) &&
        VerifyField<uint8_t>(verifier, VT_METADATA_STATE) &&
        VerifyField<uint64_t>(verifier, VT_ACTIVE_MAINTENANCE) &&
        VerifyField<uint64_t>(verifier, VT_SINCE_VERSION) &&
        verifier.EndTable();
  }
};

struct ShardStateBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_shard_idx(uint16_t shard_idx) {
    fbb_.AddElement<uint16_t>(ShardState::VT_SHARD_IDX, shard_idx, 0);
  }
  void add_storage_state(StorageState storage_state) {
    fbb_.AddElement<uint8_t>(
        ShardState::VT_STORAGE_STATE, static_cast<uint8_t>(storage_state), 0);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(ShardState::VT_FLAGS, flags, 0);
  }
  void add_metadata_state(MetaDataStorageState metadata_state) {
    fbb_.AddElement<uint8_t>(
        ShardState::VT_METADATA_STATE, static_cast<uint8_t>(metadata_state), 0);
  }
  void add_active_maintenance(uint64_t active_maintenance) {
    fbb_.AddElement<uint64_t>(
        ShardState::VT_ACTIVE_MAINTENANCE, active_maintenance, 0);
  }
  void add_since_version(uint64_t since_version) {
    fbb_.AddElement<uint64_t>(ShardState::VT_SINCE_VERSION, since_version, 0);
  }
  ShardStateBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShardStateBuilder& operator=(const ShardStateBuilder&);
  flatbuffers::Offset<ShardState> Finish() {
    auto o = flatbuffers::Offset<ShardState>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<ShardState> CreateShardState(
    flatbuffers::FlatBufferBuilder& _fbb,
    uint16_t shard_idx = 0,
    StorageState storage_state = StorageState::NONE,
    uint32_t flags = 0,
    MetaDataStorageState metadata_state = MetaDataStorageState::NONE,
    uint64_t active_maintenance = 0,
    uint64_t since_version = 0) {
  ShardStateBuilder builder_(_fbb);
  builder_.add_since_version(since_version);
  builder_.add_active_maintenance(active_maintenance);
  builder_.add_flags(flags);
  builder_.add_shard_idx(shard_idx);
  builder_.add_metadata_state(metadata_state);
  builder_.add_storage_state(storage_state);
  return builder_.Finish();
}

struct StorageNodeState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_NODE_IDX = 4, VT_SHARD_STATES = 6 };
  uint16_t node_idx() const {
    return GetField<uint16_t>(VT_NODE_IDX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShardState>>*
  shard_states() const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<ShardState>>*>(
        VT_SHARD_STATES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
        VerifyField<uint16_t>(verifier, VT_NODE_IDX) &&
        VerifyField<flatbuffers::uoffset_t>(verifier, VT_SHARD_STATES) &&
        verifier.Verify(shard_states()) &&
        verifier.VerifyVectorOfTables(shard_states()) && verifier.EndTable();
  }
};

struct StorageNodeStateBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_idx(uint16_t node_idx) {
    fbb_.AddElement<uint16_t>(StorageNodeState::VT_NODE_IDX, node_idx, 0);
  }
  void add_shard_states(
      flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShardState>>>
          shard_states) {
    fbb_.AddOffset(StorageNodeState::VT_SHARD_STATES, shard_states);
  }
  StorageNodeStateBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StorageNodeStateBuilder& operator=(const StorageNodeStateBuilder&);
  flatbuffers::Offset<StorageNodeState> Finish() {
    auto o = flatbuffers::Offset<StorageNodeState>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<StorageNodeState> CreateStorageNodeState(
    flatbuffers::FlatBufferBuilder& _fbb,
    uint16_t node_idx = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShardState>>>
        shard_states = 0) {
  StorageNodeStateBuilder builder_(_fbb);
  builder_.add_shard_states(shard_states);
  builder_.add_node_idx(node_idx);
  return builder_.Finish();
}

inline flatbuffers::Offset<StorageNodeState> CreateStorageNodeStateDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    uint16_t node_idx = 0,
    const std::vector<flatbuffers::Offset<ShardState>>* shard_states =
        nullptr) {
  return CreateStorageNodeState(
      _fbb,
      node_idx,
      shard_states
          ? _fbb.CreateVector<flatbuffers::Offset<ShardState>>(*shard_states)
          : 0);
}

struct StorageMembership FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROTO_VERSION = 4,
    VT_MEMBERSHIP_VERSION = 6,
    VT_NODE_STATES = 8,
    VT_METADATA_SHARDS = 10
  };
  uint32_t proto_version() const {
    return GetField<uint32_t>(VT_PROTO_VERSION, 0);
  }
  uint64_t membership_version() const {
    return GetField<uint64_t>(VT_MEMBERSHIP_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StorageNodeState>>*
  node_states() const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<StorageNodeState>>*>(
        VT_NODE_STATES);
  }
  const flatbuffers::Vector<const ShardID*>* metadata_shards() const {
    return GetPointer<const flatbuffers::Vector<const ShardID*>*>(
        VT_METADATA_SHARDS);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
        VerifyField<uint32_t>(verifier, VT_PROTO_VERSION) &&
        VerifyField<uint64_t>(verifier, VT_MEMBERSHIP_VERSION) &&
        VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE_STATES) &&
        verifier.Verify(node_states()) &&
        verifier.VerifyVectorOfTables(node_states()) &&
        VerifyField<flatbuffers::uoffset_t>(verifier, VT_METADATA_SHARDS) &&
        verifier.Verify(metadata_shards()) && verifier.EndTable();
  }
};

struct StorageMembershipBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_proto_version(uint32_t proto_version) {
    fbb_.AddElement<uint32_t>(
        StorageMembership::VT_PROTO_VERSION, proto_version, 0);
  }
  void add_membership_version(uint64_t membership_version) {
    fbb_.AddElement<uint64_t>(
        StorageMembership::VT_MEMBERSHIP_VERSION, membership_version, 0);
  }
  void
  add_node_states(flatbuffers::Offset<flatbuffers::Vector<
                      flatbuffers::Offset<StorageNodeState>>> node_states) {
    fbb_.AddOffset(StorageMembership::VT_NODE_STATES, node_states);
  }
  void add_metadata_shards(
      flatbuffers::Offset<flatbuffers::Vector<const ShardID*>>
          metadata_shards) {
    fbb_.AddOffset(StorageMembership::VT_METADATA_SHARDS, metadata_shards);
  }
  StorageMembershipBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StorageMembershipBuilder& operator=(const StorageMembershipBuilder&);
  flatbuffers::Offset<StorageMembership> Finish() {
    auto o = flatbuffers::Offset<StorageMembership>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<StorageMembership> CreateStorageMembership(
    flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t proto_version = 0,
    uint64_t membership_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<StorageNodeState>>> node_states = 0,
    flatbuffers::Offset<flatbuffers::Vector<const ShardID*>> metadata_shards =
        0) {
  StorageMembershipBuilder builder_(_fbb);
  builder_.add_membership_version(membership_version);
  builder_.add_metadata_shards(metadata_shards);
  builder_.add_node_states(node_states);
  builder_.add_proto_version(proto_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<StorageMembership> CreateStorageMembershipDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t proto_version = 0,
    uint64_t membership_version = 0,
    const std::vector<flatbuffers::Offset<StorageNodeState>>* node_states =
        nullptr,
    const std::vector<const ShardID*>* metadata_shards = nullptr) {
  return CreateStorageMembership(
      _fbb,
      proto_version,
      membership_version,
      node_states ? _fbb.CreateVector<flatbuffers::Offset<StorageNodeState>>(
                        *node_states)
                  : 0,
      metadata_shards ? _fbb.CreateVector<const ShardID*>(*metadata_shards)
                      : 0);
}

////////////////// Sequencer Membership ////////////////
struct SequencerNodeState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum { VT_NODE_IDX = 4, VT_WEIGHT = 6, VT_ACTIVE_MAINTENANCE = 8 };
  uint16_t node_idx() const {
    return GetField<uint16_t>(VT_NODE_IDX, 0);
  }
  double weight() const {
    return GetField<double>(VT_WEIGHT, 0.0);
  }
  uint64_t active_maintenance() const {
    return GetField<uint64_t>(VT_ACTIVE_MAINTENANCE, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
        VerifyField<uint16_t>(verifier, VT_NODE_IDX) &&
        VerifyField<double>(verifier, VT_WEIGHT) &&
        VerifyField<uint64_t>(verifier, VT_ACTIVE_MAINTENANCE) &&
        verifier.EndTable();
  }
};

struct SequencerNodeStateBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_idx(uint16_t node_idx) {
    fbb_.AddElement<uint16_t>(SequencerNodeState::VT_NODE_IDX, node_idx, 0);
  }
  void add_weight(double weight) {
    fbb_.AddElement<double>(SequencerNodeState::VT_WEIGHT, weight, 0.0);
  }
  void add_active_maintenance(uint64_t active_maintenance) {
    fbb_.AddElement<uint64_t>(
        SequencerNodeState::VT_ACTIVE_MAINTENANCE, active_maintenance, 0);
  }
  SequencerNodeStateBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequencerNodeStateBuilder& operator=(const SequencerNodeStateBuilder&);
  flatbuffers::Offset<SequencerNodeState> Finish() {
    auto o = flatbuffers::Offset<SequencerNodeState>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<SequencerNodeState>
CreateSequencerNodeState(flatbuffers::FlatBufferBuilder& _fbb,
                         uint16_t node_idx = 0,
                         double weight = 0.0,
                         uint64_t active_maintenance = 0) {
  SequencerNodeStateBuilder builder_(_fbb);
  builder_.add_active_maintenance(active_maintenance);
  builder_.add_weight(weight);
  builder_.add_node_idx(node_idx);
  return builder_.Finish();
}

struct SequencerMembership FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  enum { VT_PROTO_VERSION = 4, VT_MEMBERSHIP_VERSION = 6, VT_NODE_STATES = 8 };
  uint32_t proto_version() const {
    return GetField<uint32_t>(VT_PROTO_VERSION, 0);
  }
  uint64_t membership_version() const {
    return GetField<uint64_t>(VT_MEMBERSHIP_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SequencerNodeState>>*
  node_states() const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<SequencerNodeState>>*>(
        VT_NODE_STATES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
        VerifyField<uint32_t>(verifier, VT_PROTO_VERSION) &&
        VerifyField<uint64_t>(verifier, VT_MEMBERSHIP_VERSION) &&
        VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE_STATES) &&
        verifier.Verify(node_states()) &&
        verifier.VerifyVectorOfTables(node_states()) && verifier.EndTable();
  }
};

struct SequencerMembershipBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_proto_version(uint32_t proto_version) {
    fbb_.AddElement<uint32_t>(
        SequencerMembership::VT_PROTO_VERSION, proto_version, 0);
  }
  void add_membership_version(uint64_t membership_version) {
    fbb_.AddElement<uint64_t>(
        SequencerMembership::VT_MEMBERSHIP_VERSION, membership_version, 0);
  }
  void
  add_node_states(flatbuffers::Offset<flatbuffers::Vector<
                      flatbuffers::Offset<SequencerNodeState>>> node_states) {
    fbb_.AddOffset(SequencerMembership::VT_NODE_STATES, node_states);
  }
  SequencerMembershipBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequencerMembershipBuilder& operator=(const SequencerMembershipBuilder&);
  flatbuffers::Offset<SequencerMembership> Finish() {
    auto o = flatbuffers::Offset<SequencerMembership>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<SequencerMembership> CreateSequencerMembership(
    flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t proto_version = 0,
    uint64_t membership_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<
        flatbuffers::Offset<SequencerNodeState>>> node_states = 0) {
  SequencerMembershipBuilder builder_(_fbb);
  builder_.add_membership_version(membership_version);
  builder_.add_node_states(node_states);
  builder_.add_proto_version(proto_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<SequencerMembership> CreateSequencerMembershipDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t proto_version = 0,
    uint64_t membership_version = 0,
    const std::vector<flatbuffers::Offset<SequencerNodeState>>* node_states =
        nullptr) {
  return CreateSequencerMembership(
      _fbb,
      proto_version,
      membership_version,
      node_states ? _fbb.CreateVector<flatbuffers::Offset<SequencerNodeState>>(
                        *node_states)
                  : 0);
}

}}}} // namespace facebook::logdevice::membership::flat_buffer_codec

#endif // FLATBUFFERS_GENERATED_MEMBERSHIPCODEC_FACEBOOK_LOGDEVICE_MEMBERSHIP_FLAT_BUFFER_CODEC_H_
