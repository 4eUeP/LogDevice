// @generated
// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_NODESCONFIGURATIONCODEC_FACEBOOK_LOGDEVICE_CONFIGURATION_NODES_FLAT_BUFFER_CODEC_H_
#define FLATBUFFERS_GENERATED_NODESCONFIGURATIONCODEC_FACEBOOK_LOGDEVICE_CONFIGURATION_NODES_FLAT_BUFFER_CODEC_H_

#include "flatbuffers/flatbuffers.h"
#include "logdevice/common/membership/MembershipCodec_generated.h"

namespace facebook {
namespace logdevice {
namespace configuration {
namespace nodes {
namespace flat_buffer_codec {

struct NodeServiceDiscovery;

struct ServiceDiscoveryConfigMapItem;

struct ServiceDiscoveryConfig;

struct SequencerNodeAttribute;

struct SequencerAttributeConfigMapItem;

struct SequencerAttributeConfig;

struct StorageNodeAttribute;

struct StorageAttributeConfigMapItem;

struct StorageAttributeConfig;

struct SequencerConfig;

struct StorageConfig;

struct ScopeReplication;

struct ReplicationProperty;

struct MetaDataLogsReplication;

struct NodesConfiguration;

struct NodesConfigurationHeader;

struct NodesConfigurationWrapper;

MANUALLY_ALIGNED_STRUCT(1) ScopeReplication FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t scope_;
  uint8_t replication_factor_;

 public:
  ScopeReplication() { memset(this, 0, sizeof(ScopeReplication)); }
  ScopeReplication(const ScopeReplication &_o) { memcpy(this, &_o, sizeof(ScopeReplication)); }
  ScopeReplication(uint8_t _scope, uint8_t _replication_factor)
    : scope_(flatbuffers::EndianScalar(_scope)), replication_factor_(flatbuffers::EndianScalar(_replication_factor)) { }

  uint8_t scope() const { return flatbuffers::EndianScalar(scope_); }
  uint8_t replication_factor() const { return flatbuffers::EndianScalar(replication_factor_); }
};
STRUCT_END(ScopeReplication, 2);

struct NodeServiceDiscovery FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_GOSSIP_ADDRESS = 6,
    VT_SSL_ADDRESS = 8,
    VT_LOCATION = 10,
    VT_ROLES = 12,
    VT_HOSTNAME = 14
  };
  const flatbuffers::String *address() const { return GetPointer<const flatbuffers::String *>(VT_ADDRESS); }
  const flatbuffers::String *gossip_address() const { return GetPointer<const flatbuffers::String *>(VT_GOSSIP_ADDRESS); }
  const flatbuffers::String *ssl_address() const { return GetPointer<const flatbuffers::String *>(VT_SSL_ADDRESS); }
  const flatbuffers::String *location() const { return GetPointer<const flatbuffers::String *>(VT_LOCATION); }
  uint64_t roles() const { return GetField<uint64_t>(VT_ROLES, 0); }
  const flatbuffers::String *hostname() const { return GetPointer<const flatbuffers::String *>(VT_HOSTNAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_GOSSIP_ADDRESS) &&
           verifier.Verify(gossip_address()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SSL_ADDRESS) &&
           verifier.Verify(ssl_address()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LOCATION) &&
           verifier.Verify(location()) &&
           VerifyField<uint64_t>(verifier, VT_ROLES) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HOSTNAME) &&
           verifier.Verify(hostname()) &&
           verifier.EndTable();
  }
};

struct NodeServiceDiscoveryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) { fbb_.AddOffset(NodeServiceDiscovery::VT_ADDRESS, address); }
  void add_gossip_address(flatbuffers::Offset<flatbuffers::String> gossip_address) { fbb_.AddOffset(NodeServiceDiscovery::VT_GOSSIP_ADDRESS, gossip_address); }
  void add_ssl_address(flatbuffers::Offset<flatbuffers::String> ssl_address) { fbb_.AddOffset(NodeServiceDiscovery::VT_SSL_ADDRESS, ssl_address); }
  void add_location(flatbuffers::Offset<flatbuffers::String> location) { fbb_.AddOffset(NodeServiceDiscovery::VT_LOCATION, location); }
  void add_roles(uint64_t roles) { fbb_.AddElement<uint64_t>(NodeServiceDiscovery::VT_ROLES, roles, 0); }
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) { fbb_.AddOffset(NodeServiceDiscovery::VT_HOSTNAME, hostname); }
  NodeServiceDiscoveryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeServiceDiscoveryBuilder &operator=(const NodeServiceDiscoveryBuilder &);
  flatbuffers::Offset<NodeServiceDiscovery> Finish() {
    auto o = flatbuffers::Offset<NodeServiceDiscovery>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<NodeServiceDiscovery> CreateNodeServiceDiscovery(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    flatbuffers::Offset<flatbuffers::String> gossip_address = 0,
    flatbuffers::Offset<flatbuffers::String> ssl_address = 0,
    flatbuffers::Offset<flatbuffers::String> location = 0,
    uint64_t roles = 0,
    flatbuffers::Offset<flatbuffers::String> hostname = 0) {
  NodeServiceDiscoveryBuilder builder_(_fbb);
  builder_.add_roles(roles);
  builder_.add_hostname(hostname);
  builder_.add_location(location);
  builder_.add_ssl_address(ssl_address);
  builder_.add_gossip_address(gossip_address);
  builder_.add_address(address);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeServiceDiscovery> CreateNodeServiceDiscoveryDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    const char *gossip_address = nullptr,
    const char *ssl_address = nullptr,
    const char *location = nullptr,
    uint64_t roles = 0,
    const char *hostname = nullptr) {
  return CreateNodeServiceDiscovery(_fbb, address ? _fbb.CreateString(address) : 0, gossip_address ? _fbb.CreateString(gossip_address) : 0, ssl_address ? _fbb.CreateString(ssl_address) : 0, location ? _fbb.CreateString(location) : 0, roles, hostname ? _fbb.CreateString(hostname) : 0);
}

struct ServiceDiscoveryConfigMapItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE_IDX = 4,
    VT_NODE_ATTRIBUTE = 6
  };
  uint16_t node_idx() const { return GetField<uint16_t>(VT_NODE_IDX, 0); }
  const NodeServiceDiscovery *node_attribute() const { return GetPointer<const NodeServiceDiscovery *>(VT_NODE_ATTRIBUTE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_NODE_IDX) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE_ATTRIBUTE) &&
           verifier.VerifyTable(node_attribute()) &&
           verifier.EndTable();
  }
};

struct ServiceDiscoveryConfigMapItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_idx(uint16_t node_idx) { fbb_.AddElement<uint16_t>(ServiceDiscoveryConfigMapItem::VT_NODE_IDX, node_idx, 0); }
  void add_node_attribute(flatbuffers::Offset<NodeServiceDiscovery> node_attribute) { fbb_.AddOffset(ServiceDiscoveryConfigMapItem::VT_NODE_ATTRIBUTE, node_attribute); }
  ServiceDiscoveryConfigMapItemBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ServiceDiscoveryConfigMapItemBuilder &operator=(const ServiceDiscoveryConfigMapItemBuilder &);
  flatbuffers::Offset<ServiceDiscoveryConfigMapItem> Finish() {
    auto o = flatbuffers::Offset<ServiceDiscoveryConfigMapItem>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ServiceDiscoveryConfigMapItem> CreateServiceDiscoveryConfigMapItem(flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t node_idx = 0,
    flatbuffers::Offset<NodeServiceDiscovery> node_attribute = 0) {
  ServiceDiscoveryConfigMapItemBuilder builder_(_fbb);
  builder_.add_node_attribute(node_attribute);
  builder_.add_node_idx(node_idx);
  return builder_.Finish();
}

struct ServiceDiscoveryConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE_STATES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ServiceDiscoveryConfigMapItem>> *node_states() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ServiceDiscoveryConfigMapItem>> *>(VT_NODE_STATES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE_STATES) &&
           verifier.Verify(node_states()) &&
           verifier.VerifyVectorOfTables(node_states()) &&
           verifier.EndTable();
  }
};

struct ServiceDiscoveryConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServiceDiscoveryConfigMapItem>>> node_states) { fbb_.AddOffset(ServiceDiscoveryConfig::VT_NODE_STATES, node_states); }
  ServiceDiscoveryConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ServiceDiscoveryConfigBuilder &operator=(const ServiceDiscoveryConfigBuilder &);
  flatbuffers::Offset<ServiceDiscoveryConfig> Finish() {
    auto o = flatbuffers::Offset<ServiceDiscoveryConfig>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ServiceDiscoveryConfig> CreateServiceDiscoveryConfig(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServiceDiscoveryConfigMapItem>>> node_states = 0) {
  ServiceDiscoveryConfigBuilder builder_(_fbb);
  builder_.add_node_states(node_states);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServiceDiscoveryConfig> CreateServiceDiscoveryConfigDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ServiceDiscoveryConfigMapItem>> *node_states = nullptr) {
  return CreateServiceDiscoveryConfig(_fbb, node_states ? _fbb.CreateVector<flatbuffers::Offset<ServiceDiscoveryConfigMapItem>>(*node_states) : 0);
}

struct SequencerNodeAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SequencerNodeAttributeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  SequencerNodeAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SequencerNodeAttributeBuilder &operator=(const SequencerNodeAttributeBuilder &);
  flatbuffers::Offset<SequencerNodeAttribute> Finish() {
    auto o = flatbuffers::Offset<SequencerNodeAttribute>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<SequencerNodeAttribute> CreateSequencerNodeAttribute(flatbuffers::FlatBufferBuilder &_fbb) {
  SequencerNodeAttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SequencerAttributeConfigMapItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE_IDX = 4,
    VT_NODE_ATTRIBUTE = 6
  };
  uint16_t node_idx() const { return GetField<uint16_t>(VT_NODE_IDX, 0); }
  const SequencerNodeAttribute *node_attribute() const { return GetPointer<const SequencerNodeAttribute *>(VT_NODE_ATTRIBUTE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_NODE_IDX) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE_ATTRIBUTE) &&
           verifier.VerifyTable(node_attribute()) &&
           verifier.EndTable();
  }
};

struct SequencerAttributeConfigMapItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_idx(uint16_t node_idx) { fbb_.AddElement<uint16_t>(SequencerAttributeConfigMapItem::VT_NODE_IDX, node_idx, 0); }
  void add_node_attribute(flatbuffers::Offset<SequencerNodeAttribute> node_attribute) { fbb_.AddOffset(SequencerAttributeConfigMapItem::VT_NODE_ATTRIBUTE, node_attribute); }
  SequencerAttributeConfigMapItemBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SequencerAttributeConfigMapItemBuilder &operator=(const SequencerAttributeConfigMapItemBuilder &);
  flatbuffers::Offset<SequencerAttributeConfigMapItem> Finish() {
    auto o = flatbuffers::Offset<SequencerAttributeConfigMapItem>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<SequencerAttributeConfigMapItem> CreateSequencerAttributeConfigMapItem(flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t node_idx = 0,
    flatbuffers::Offset<SequencerNodeAttribute> node_attribute = 0) {
  SequencerAttributeConfigMapItemBuilder builder_(_fbb);
  builder_.add_node_attribute(node_attribute);
  builder_.add_node_idx(node_idx);
  return builder_.Finish();
}

struct SequencerAttributeConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE_STATES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SequencerAttributeConfigMapItem>> *node_states() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SequencerAttributeConfigMapItem>> *>(VT_NODE_STATES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE_STATES) &&
           verifier.Verify(node_states()) &&
           verifier.VerifyVectorOfTables(node_states()) &&
           verifier.EndTable();
  }
};

struct SequencerAttributeConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SequencerAttributeConfigMapItem>>> node_states) { fbb_.AddOffset(SequencerAttributeConfig::VT_NODE_STATES, node_states); }
  SequencerAttributeConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SequencerAttributeConfigBuilder &operator=(const SequencerAttributeConfigBuilder &);
  flatbuffers::Offset<SequencerAttributeConfig> Finish() {
    auto o = flatbuffers::Offset<SequencerAttributeConfig>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<SequencerAttributeConfig> CreateSequencerAttributeConfig(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SequencerAttributeConfigMapItem>>> node_states = 0) {
  SequencerAttributeConfigBuilder builder_(_fbb);
  builder_.add_node_states(node_states);
  return builder_.Finish();
}

inline flatbuffers::Offset<SequencerAttributeConfig> CreateSequencerAttributeConfigDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SequencerAttributeConfigMapItem>> *node_states = nullptr) {
  return CreateSequencerAttributeConfig(_fbb, node_states ? _fbb.CreateVector<flatbuffers::Offset<SequencerAttributeConfigMapItem>>(*node_states) : 0);
}

struct StorageNodeAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CAPACITY = 4,
    VT_NUM_SHARDS = 6,
    VT_GENERATION = 8,
    VT_EXCLUDE_FROM_NODESETS = 10
  };
  double capacity() const { return GetField<double>(VT_CAPACITY, 0.0); }
  int16_t num_shards() const { return GetField<int16_t>(VT_NUM_SHARDS, 0); }
  uint16_t generation() const { return GetField<uint16_t>(VT_GENERATION, 0); }
  bool exclude_from_nodesets() const { return GetField<uint8_t>(VT_EXCLUDE_FROM_NODESETS, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_CAPACITY) &&
           VerifyField<int16_t>(verifier, VT_NUM_SHARDS) &&
           VerifyField<uint16_t>(verifier, VT_GENERATION) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUDE_FROM_NODESETS) &&
           verifier.EndTable();
  }
};

struct StorageNodeAttributeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_capacity(double capacity) { fbb_.AddElement<double>(StorageNodeAttribute::VT_CAPACITY, capacity, 0.0); }
  void add_num_shards(int16_t num_shards) { fbb_.AddElement<int16_t>(StorageNodeAttribute::VT_NUM_SHARDS, num_shards, 0); }
  void add_generation(uint16_t generation) { fbb_.AddElement<uint16_t>(StorageNodeAttribute::VT_GENERATION, generation, 0); }
  void add_exclude_from_nodesets(bool exclude_from_nodesets) { fbb_.AddElement<uint8_t>(StorageNodeAttribute::VT_EXCLUDE_FROM_NODESETS, static_cast<uint8_t>(exclude_from_nodesets), 0); }
  StorageNodeAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StorageNodeAttributeBuilder &operator=(const StorageNodeAttributeBuilder &);
  flatbuffers::Offset<StorageNodeAttribute> Finish() {
    auto o = flatbuffers::Offset<StorageNodeAttribute>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<StorageNodeAttribute> CreateStorageNodeAttribute(flatbuffers::FlatBufferBuilder &_fbb,
    double capacity = 0.0,
    int16_t num_shards = 0,
    uint16_t generation = 0,
    bool exclude_from_nodesets = false) {
  StorageNodeAttributeBuilder builder_(_fbb);
  builder_.add_capacity(capacity);
  builder_.add_generation(generation);
  builder_.add_num_shards(num_shards);
  builder_.add_exclude_from_nodesets(exclude_from_nodesets);
  return builder_.Finish();
}

struct StorageAttributeConfigMapItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE_IDX = 4,
    VT_NODE_ATTRIBUTE = 6
  };
  uint16_t node_idx() const { return GetField<uint16_t>(VT_NODE_IDX, 0); }
  const StorageNodeAttribute *node_attribute() const { return GetPointer<const StorageNodeAttribute *>(VT_NODE_ATTRIBUTE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_NODE_IDX) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE_ATTRIBUTE) &&
           verifier.VerifyTable(node_attribute()) &&
           verifier.EndTable();
  }
};

struct StorageAttributeConfigMapItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_idx(uint16_t node_idx) { fbb_.AddElement<uint16_t>(StorageAttributeConfigMapItem::VT_NODE_IDX, node_idx, 0); }
  void add_node_attribute(flatbuffers::Offset<StorageNodeAttribute> node_attribute) { fbb_.AddOffset(StorageAttributeConfigMapItem::VT_NODE_ATTRIBUTE, node_attribute); }
  StorageAttributeConfigMapItemBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StorageAttributeConfigMapItemBuilder &operator=(const StorageAttributeConfigMapItemBuilder &);
  flatbuffers::Offset<StorageAttributeConfigMapItem> Finish() {
    auto o = flatbuffers::Offset<StorageAttributeConfigMapItem>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<StorageAttributeConfigMapItem> CreateStorageAttributeConfigMapItem(flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t node_idx = 0,
    flatbuffers::Offset<StorageNodeAttribute> node_attribute = 0) {
  StorageAttributeConfigMapItemBuilder builder_(_fbb);
  builder_.add_node_attribute(node_attribute);
  builder_.add_node_idx(node_idx);
  return builder_.Finish();
}

struct StorageAttributeConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE_STATES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<StorageAttributeConfigMapItem>> *node_states() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StorageAttributeConfigMapItem>> *>(VT_NODE_STATES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE_STATES) &&
           verifier.Verify(node_states()) &&
           verifier.VerifyVectorOfTables(node_states()) &&
           verifier.EndTable();
  }
};

struct StorageAttributeConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StorageAttributeConfigMapItem>>> node_states) { fbb_.AddOffset(StorageAttributeConfig::VT_NODE_STATES, node_states); }
  StorageAttributeConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StorageAttributeConfigBuilder &operator=(const StorageAttributeConfigBuilder &);
  flatbuffers::Offset<StorageAttributeConfig> Finish() {
    auto o = flatbuffers::Offset<StorageAttributeConfig>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<StorageAttributeConfig> CreateStorageAttributeConfig(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StorageAttributeConfigMapItem>>> node_states = 0) {
  StorageAttributeConfigBuilder builder_(_fbb);
  builder_.add_node_states(node_states);
  return builder_.Finish();
}

inline flatbuffers::Offset<StorageAttributeConfig> CreateStorageAttributeConfigDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<StorageAttributeConfigMapItem>> *node_states = nullptr) {
  return CreateStorageAttributeConfig(_fbb, node_states ? _fbb.CreateVector<flatbuffers::Offset<StorageAttributeConfigMapItem>>(*node_states) : 0);
}

struct SequencerConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTR_CONF = 4,
    VT_MEMBERSHIP = 6
  };
  const SequencerAttributeConfig *attr_conf() const { return GetPointer<const SequencerAttributeConfig *>(VT_ATTR_CONF); }
  const facebook::logdevice::membership::flat_buffer_codec::SequencerMembership *membership() const { return GetPointer<const facebook::logdevice::membership::flat_buffer_codec::SequencerMembership *>(VT_MEMBERSHIP); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTR_CONF) &&
           verifier.VerifyTable(attr_conf()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MEMBERSHIP) &&
           verifier.VerifyTable(membership()) &&
           verifier.EndTable();
  }
};

struct SequencerConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attr_conf(flatbuffers::Offset<SequencerAttributeConfig> attr_conf) { fbb_.AddOffset(SequencerConfig::VT_ATTR_CONF, attr_conf); }
  void add_membership(flatbuffers::Offset<facebook::logdevice::membership::flat_buffer_codec::SequencerMembership> membership) { fbb_.AddOffset(SequencerConfig::VT_MEMBERSHIP, membership); }
  SequencerConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SequencerConfigBuilder &operator=(const SequencerConfigBuilder &);
  flatbuffers::Offset<SequencerConfig> Finish() {
    auto o = flatbuffers::Offset<SequencerConfig>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<SequencerConfig> CreateSequencerConfig(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SequencerAttributeConfig> attr_conf = 0,
    flatbuffers::Offset<facebook::logdevice::membership::flat_buffer_codec::SequencerMembership> membership = 0) {
  SequencerConfigBuilder builder_(_fbb);
  builder_.add_membership(membership);
  builder_.add_attr_conf(attr_conf);
  return builder_.Finish();
}

struct StorageConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTR_CONF = 4,
    VT_MEMBERSHIP = 6
  };
  const StorageAttributeConfig *attr_conf() const { return GetPointer<const StorageAttributeConfig *>(VT_ATTR_CONF); }
  const facebook::logdevice::membership::flat_buffer_codec::StorageMembership *membership() const { return GetPointer<const facebook::logdevice::membership::flat_buffer_codec::StorageMembership *>(VT_MEMBERSHIP); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTR_CONF) &&
           verifier.VerifyTable(attr_conf()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MEMBERSHIP) &&
           verifier.VerifyTable(membership()) &&
           verifier.EndTable();
  }
};

struct StorageConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attr_conf(flatbuffers::Offset<StorageAttributeConfig> attr_conf) { fbb_.AddOffset(StorageConfig::VT_ATTR_CONF, attr_conf); }
  void add_membership(flatbuffers::Offset<facebook::logdevice::membership::flat_buffer_codec::StorageMembership> membership) { fbb_.AddOffset(StorageConfig::VT_MEMBERSHIP, membership); }
  StorageConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StorageConfigBuilder &operator=(const StorageConfigBuilder &);
  flatbuffers::Offset<StorageConfig> Finish() {
    auto o = flatbuffers::Offset<StorageConfig>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<StorageConfig> CreateStorageConfig(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<StorageAttributeConfig> attr_conf = 0,
    flatbuffers::Offset<facebook::logdevice::membership::flat_buffer_codec::StorageMembership> membership = 0) {
  StorageConfigBuilder builder_(_fbb);
  builder_.add_membership(membership);
  builder_.add_attr_conf(attr_conf);
  return builder_.Finish();
}

struct ReplicationProperty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCOPES = 4
  };
  const flatbuffers::Vector<const ScopeReplication *> *scopes() const { return GetPointer<const flatbuffers::Vector<const ScopeReplication *> *>(VT_SCOPES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SCOPES) &&
           verifier.Verify(scopes()) &&
           verifier.EndTable();
  }
};

struct ReplicationPropertyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scopes(flatbuffers::Offset<flatbuffers::Vector<const ScopeReplication *>> scopes) { fbb_.AddOffset(ReplicationProperty::VT_SCOPES, scopes); }
  ReplicationPropertyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ReplicationPropertyBuilder &operator=(const ReplicationPropertyBuilder &);
  flatbuffers::Offset<ReplicationProperty> Finish() {
    auto o = flatbuffers::Offset<ReplicationProperty>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ReplicationProperty> CreateReplicationProperty(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const ScopeReplication *>> scopes = 0) {
  ReplicationPropertyBuilder builder_(_fbb);
  builder_.add_scopes(scopes);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReplicationProperty> CreateReplicationPropertyDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<const ScopeReplication *> *scopes = nullptr) {
  return CreateReplicationProperty(_fbb, scopes ? _fbb.CreateVector<const ScopeReplication *>(*scopes) : 0);
}

struct MetaDataLogsReplication FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_REPLICATION = 6
  };
  uint64_t version() const { return GetField<uint64_t>(VT_VERSION, 0); }
  const ReplicationProperty *replication() const { return GetPointer<const ReplicationProperty *>(VT_REPLICATION); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_REPLICATION) &&
           verifier.VerifyTable(replication()) &&
           verifier.EndTable();
  }
};

struct MetaDataLogsReplicationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint64_t version) { fbb_.AddElement<uint64_t>(MetaDataLogsReplication::VT_VERSION, version, 0); }
  void add_replication(flatbuffers::Offset<ReplicationProperty> replication) { fbb_.AddOffset(MetaDataLogsReplication::VT_REPLICATION, replication); }
  MetaDataLogsReplicationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MetaDataLogsReplicationBuilder &operator=(const MetaDataLogsReplicationBuilder &);
  flatbuffers::Offset<MetaDataLogsReplication> Finish() {
    auto o = flatbuffers::Offset<MetaDataLogsReplication>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<MetaDataLogsReplication> CreateMetaDataLogsReplication(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t version = 0,
    flatbuffers::Offset<ReplicationProperty> replication = 0) {
  MetaDataLogsReplicationBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_replication(replication);
  return builder_.Finish();
}

struct NodesConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROTO_VERSION = 4,
    VT_VERSION = 6,
    VT_SERVICE_DISCOVERY = 8,
    VT_SEQUENCER_CONFIG = 10,
    VT_STORAGE_CONFIG = 12,
    VT_METADATA_LOGS_REP = 14,
    VT_LAST_TIMESTAMP = 16,
    VT_LAST_MAINTENANCE = 18,
    VT_LAST_CONTEXT = 20
  };
  uint32_t proto_version() const { return GetField<uint32_t>(VT_PROTO_VERSION, 0); }
  uint64_t version() const { return GetField<uint64_t>(VT_VERSION, 0); }
  const ServiceDiscoveryConfig *service_discovery() const { return GetPointer<const ServiceDiscoveryConfig *>(VT_SERVICE_DISCOVERY); }
  const SequencerConfig *sequencer_config() const { return GetPointer<const SequencerConfig *>(VT_SEQUENCER_CONFIG); }
  const StorageConfig *storage_config() const { return GetPointer<const StorageConfig *>(VT_STORAGE_CONFIG); }
  const MetaDataLogsReplication *metadata_logs_rep() const { return GetPointer<const MetaDataLogsReplication *>(VT_METADATA_LOGS_REP); }
  uint64_t last_timestamp() const { return GetField<uint64_t>(VT_LAST_TIMESTAMP, 0); }
  uint64_t last_maintenance() const { return GetField<uint64_t>(VT_LAST_MAINTENANCE, 0); }
  const flatbuffers::String *last_context() const { return GetPointer<const flatbuffers::String *>(VT_LAST_CONTEXT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROTO_VERSION) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SERVICE_DISCOVERY) &&
           verifier.VerifyTable(service_discovery()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SEQUENCER_CONFIG) &&
           verifier.VerifyTable(sequencer_config()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_STORAGE_CONFIG) &&
           verifier.VerifyTable(storage_config()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_METADATA_LOGS_REP) &&
           verifier.VerifyTable(metadata_logs_rep()) &&
           VerifyField<uint64_t>(verifier, VT_LAST_TIMESTAMP) &&
           VerifyField<uint64_t>(verifier, VT_LAST_MAINTENANCE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LAST_CONTEXT) &&
           verifier.Verify(last_context()) &&
           verifier.EndTable();
  }
};

struct NodesConfigurationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_proto_version(uint32_t proto_version) { fbb_.AddElement<uint32_t>(NodesConfiguration::VT_PROTO_VERSION, proto_version, 0); }
  void add_version(uint64_t version) { fbb_.AddElement<uint64_t>(NodesConfiguration::VT_VERSION, version, 0); }
  void add_service_discovery(flatbuffers::Offset<ServiceDiscoveryConfig> service_discovery) { fbb_.AddOffset(NodesConfiguration::VT_SERVICE_DISCOVERY, service_discovery); }
  void add_sequencer_config(flatbuffers::Offset<SequencerConfig> sequencer_config) { fbb_.AddOffset(NodesConfiguration::VT_SEQUENCER_CONFIG, sequencer_config); }
  void add_storage_config(flatbuffers::Offset<StorageConfig> storage_config) { fbb_.AddOffset(NodesConfiguration::VT_STORAGE_CONFIG, storage_config); }
  void add_metadata_logs_rep(flatbuffers::Offset<MetaDataLogsReplication> metadata_logs_rep) { fbb_.AddOffset(NodesConfiguration::VT_METADATA_LOGS_REP, metadata_logs_rep); }
  void add_last_timestamp(uint64_t last_timestamp) { fbb_.AddElement<uint64_t>(NodesConfiguration::VT_LAST_TIMESTAMP, last_timestamp, 0); }
  void add_last_maintenance(uint64_t last_maintenance) { fbb_.AddElement<uint64_t>(NodesConfiguration::VT_LAST_MAINTENANCE, last_maintenance, 0); }
  void add_last_context(flatbuffers::Offset<flatbuffers::String> last_context) { fbb_.AddOffset(NodesConfiguration::VT_LAST_CONTEXT, last_context); }
  NodesConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodesConfigurationBuilder &operator=(const NodesConfigurationBuilder &);
  flatbuffers::Offset<NodesConfiguration> Finish() {
    auto o = flatbuffers::Offset<NodesConfiguration>(fbb_.EndTable(start_, 9));
    return o;
  }
};

inline flatbuffers::Offset<NodesConfiguration> CreateNodesConfiguration(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t proto_version = 0,
    uint64_t version = 0,
    flatbuffers::Offset<ServiceDiscoveryConfig> service_discovery = 0,
    flatbuffers::Offset<SequencerConfig> sequencer_config = 0,
    flatbuffers::Offset<StorageConfig> storage_config = 0,
    flatbuffers::Offset<MetaDataLogsReplication> metadata_logs_rep = 0,
    uint64_t last_timestamp = 0,
    uint64_t last_maintenance = 0,
    flatbuffers::Offset<flatbuffers::String> last_context = 0) {
  NodesConfigurationBuilder builder_(_fbb);
  builder_.add_last_maintenance(last_maintenance);
  builder_.add_last_timestamp(last_timestamp);
  builder_.add_version(version);
  builder_.add_last_context(last_context);
  builder_.add_metadata_logs_rep(metadata_logs_rep);
  builder_.add_storage_config(storage_config);
  builder_.add_sequencer_config(sequencer_config);
  builder_.add_service_discovery(service_discovery);
  builder_.add_proto_version(proto_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodesConfiguration> CreateNodesConfigurationDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t proto_version = 0,
    uint64_t version = 0,
    flatbuffers::Offset<ServiceDiscoveryConfig> service_discovery = 0,
    flatbuffers::Offset<SequencerConfig> sequencer_config = 0,
    flatbuffers::Offset<StorageConfig> storage_config = 0,
    flatbuffers::Offset<MetaDataLogsReplication> metadata_logs_rep = 0,
    uint64_t last_timestamp = 0,
    uint64_t last_maintenance = 0,
    const char *last_context = nullptr) {
  return CreateNodesConfiguration(_fbb, proto_version, version, service_discovery, sequencer_config, storage_config, metadata_logs_rep, last_timestamp, last_maintenance, last_context ? _fbb.CreateString(last_context) : 0);
}

struct NodesConfigurationHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROTO_VERSION = 4,
    VT_CONFIG_VERSION = 6,
    VT_IS_COMPRESSED = 8
  };
  uint32_t proto_version() const { return GetField<uint32_t>(VT_PROTO_VERSION, 0); }
  uint64_t config_version() const { return GetField<uint64_t>(VT_CONFIG_VERSION, 0); }
  bool is_compressed() const { return GetField<uint8_t>(VT_IS_COMPRESSED, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROTO_VERSION) &&
           VerifyField<uint64_t>(verifier, VT_CONFIG_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_IS_COMPRESSED) &&
           verifier.EndTable();
  }
};

struct NodesConfigurationHeaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_proto_version(uint32_t proto_version) { fbb_.AddElement<uint32_t>(NodesConfigurationHeader::VT_PROTO_VERSION, proto_version, 0); }
  void add_config_version(uint64_t config_version) { fbb_.AddElement<uint64_t>(NodesConfigurationHeader::VT_CONFIG_VERSION, config_version, 0); }
  void add_is_compressed(bool is_compressed) { fbb_.AddElement<uint8_t>(NodesConfigurationHeader::VT_IS_COMPRESSED, static_cast<uint8_t>(is_compressed), 0); }
  NodesConfigurationHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodesConfigurationHeaderBuilder &operator=(const NodesConfigurationHeaderBuilder &);
  flatbuffers::Offset<NodesConfigurationHeader> Finish() {
    auto o = flatbuffers::Offset<NodesConfigurationHeader>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<NodesConfigurationHeader> CreateNodesConfigurationHeader(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t proto_version = 0,
    uint64_t config_version = 0,
    bool is_compressed = false) {
  NodesConfigurationHeaderBuilder builder_(_fbb);
  builder_.add_config_version(config_version);
  builder_.add_proto_version(proto_version);
  builder_.add_is_compressed(is_compressed);
  return builder_.Finish();
}

struct NodesConfigurationWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_SERIALIZED_CONFIG = 6
  };
  const NodesConfigurationHeader *header() const { return GetPointer<const NodesConfigurationHeader *>(VT_HEADER); }
  const flatbuffers::Vector<uint8_t> *serialized_config() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_CONFIG); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SERIALIZED_CONFIG) &&
           verifier.Verify(serialized_config()) &&
           verifier.EndTable();
  }
};

struct NodesConfigurationWrapperBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<NodesConfigurationHeader> header) { fbb_.AddOffset(NodesConfigurationWrapper::VT_HEADER, header); }
  void add_serialized_config(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialized_config) { fbb_.AddOffset(NodesConfigurationWrapper::VT_SERIALIZED_CONFIG, serialized_config); }
  NodesConfigurationWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodesConfigurationWrapperBuilder &operator=(const NodesConfigurationWrapperBuilder &);
  flatbuffers::Offset<NodesConfigurationWrapper> Finish() {
    auto o = flatbuffers::Offset<NodesConfigurationWrapper>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<NodesConfigurationWrapper> CreateNodesConfigurationWrapper(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NodesConfigurationHeader> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialized_config = 0) {
  NodesConfigurationWrapperBuilder builder_(_fbb);
  builder_.add_serialized_config(serialized_config);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodesConfigurationWrapper> CreateNodesConfigurationWrapperDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NodesConfigurationHeader> header = 0,
    const std::vector<uint8_t> *serialized_config = nullptr) {
  return CreateNodesConfigurationWrapper(_fbb, header, serialized_config ? _fbb.CreateVector<uint8_t>(*serialized_config) : 0);
}

inline const facebook::logdevice::configuration::nodes::flat_buffer_codec::NodesConfigurationWrapper *GetNodesConfigurationWrapper(const void *buf) {
  return flatbuffers::GetRoot<facebook::logdevice::configuration::nodes::flat_buffer_codec::NodesConfigurationWrapper>(buf);
}

inline bool VerifyNodesConfigurationWrapperBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<facebook::logdevice::configuration::nodes::flat_buffer_codec::NodesConfigurationWrapper>(nullptr);
}

inline void FinishNodesConfigurationWrapperBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<facebook::logdevice::configuration::nodes::flat_buffer_codec::NodesConfigurationWrapper> root) {
  fbb.Finish(root);
}

}  // namespace flat_buffer_codec
}  // namespace nodes
}  // namespace configuration
}  // namespace logdevice
}  // namespace facebook

#endif  // FLATBUFFERS_GENERATED_NODESCONFIGURATIONCODEC_FACEBOOK_LOGDEVICE_CONFIGURATION_NODES_FLAT_BUFFER_CODEC_H_
