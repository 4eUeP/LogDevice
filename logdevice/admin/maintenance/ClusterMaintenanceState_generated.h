// @generated
// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CLUSTERMAINTENANCESTATE_FACEBOOK_LOGDEVICE_CLUSTER_MAINTENANCE_STATE_FBUFFERS_H_
#define FLATBUFFERS_GENERATED_CLUSTERMAINTENANCESTATE_FACEBOOK_LOGDEVICE_CLUSTER_MAINTENANCE_STATE_FBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace facebook {
namespace logdevice {
namespace cluster_maintenance_state {
namespace fbuffers {

struct MaintenanceMetadata;

struct SequencerMaintenance;

struct ShardMaintenance;

struct SequencerState;

struct ShardState;

struct NodeState;

struct ClusterState;

enum class ShardOperationalState : int16_t {
  UNKNOWN = 0,
  ENABLED = 1,
  MAY_DISAPPEAR = 2,
  DRAINED = 3,
  DOWN = 4,
  DRAINING = 5,
  ENABLING = 6,
  PROVISIONING = 7,
  INVALID = 8,
  MIN = UNKNOWN,
  MAX = INVALID
};

inline const char **EnumNamesShardOperationalState() {
  static const char *names[] = { "UNKNOWN", "ENABLED", "MAY_DISAPPEAR", "DRAINED", "DOWN", "DRAINING", "ENABLING", "PROVISIONING", "INVALID", nullptr };
  return names;
}

inline const char *EnumNameShardOperationalState(ShardOperationalState e) { return EnumNamesShardOperationalState()[static_cast<int>(e)]; }

enum class SequencingState : int16_t {
  UNKNOWN = 0,
  ENABLED = 1,
  BOYCOTTED = 2,
  DISABLED = 3,
  DISABLING = 4,
  ENABLING = 5,
  INVALID = 6,
  MIN = UNKNOWN,
  MAX = INVALID
};

inline const char **EnumNamesSequencingState() {
  static const char *names[] = { "UNKNOWN", "ENABLED", "BOYCOTTED", "DISABLED", "DISABLING", "ENABLING", "INVALID", nullptr };
  return names;
}

inline const char *EnumNameSequencingState(SequencingState e) { return EnumNamesSequencingState()[static_cast<int>(e)]; }

struct MaintenanceMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINTENANCE_ID = 4,
    VT_USER_ID = 6,
    VT_COMMENT = 8,
    VT_CREATED_ON = 10
  };
  uint64_t maintenance_id() const { return GetField<uint64_t>(VT_MAINTENANCE_ID, 0); }
  const flatbuffers::String *user_id() const { return GetPointer<const flatbuffers::String *>(VT_USER_ID); }
  const flatbuffers::String *comment() const { return GetPointer<const flatbuffers::String *>(VT_COMMENT); }
  uint64_t created_on() const { return GetField<uint64_t>(VT_CREATED_ON, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MAINTENANCE_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USER_ID) &&
           verifier.Verify(user_id()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMENT) &&
           verifier.Verify(comment()) &&
           VerifyField<uint64_t>(verifier, VT_CREATED_ON) &&
           verifier.EndTable();
  }
};

struct MaintenanceMetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maintenance_id(uint64_t maintenance_id) { fbb_.AddElement<uint64_t>(MaintenanceMetadata::VT_MAINTENANCE_ID, maintenance_id, 0); }
  void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) { fbb_.AddOffset(MaintenanceMetadata::VT_USER_ID, user_id); }
  void add_comment(flatbuffers::Offset<flatbuffers::String> comment) { fbb_.AddOffset(MaintenanceMetadata::VT_COMMENT, comment); }
  void add_created_on(uint64_t created_on) { fbb_.AddElement<uint64_t>(MaintenanceMetadata::VT_CREATED_ON, created_on, 0); }
  MaintenanceMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MaintenanceMetadataBuilder &operator=(const MaintenanceMetadataBuilder &);
  flatbuffers::Offset<MaintenanceMetadata> Finish() {
    auto o = flatbuffers::Offset<MaintenanceMetadata>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<MaintenanceMetadata> CreateMaintenanceMetadata(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t maintenance_id = 0,
    flatbuffers::Offset<flatbuffers::String> user_id = 0,
    flatbuffers::Offset<flatbuffers::String> comment = 0,
    uint64_t created_on = 0) {
  MaintenanceMetadataBuilder builder_(_fbb);
  builder_.add_created_on(created_on);
  builder_.add_maintenance_id(maintenance_id);
  builder_.add_comment(comment);
  builder_.add_user_id(user_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaintenanceMetadata> CreateMaintenanceMetadataDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t maintenance_id = 0,
    const char *user_id = nullptr,
    const char *comment = nullptr,
    uint64_t created_on = 0) {
  return CreateMaintenanceMetadata(_fbb, maintenance_id, user_id ? _fbb.CreateString(user_id) : 0, comment ? _fbb.CreateString(comment) : 0, created_on);
}

struct SequencerMaintenance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINTENANCE_ID = 4,
    VT_TARGET_MAINTENANCE_STATE = 6
  };
  uint64_t maintenance_id() const { return GetField<uint64_t>(VT_MAINTENANCE_ID, 0); }
  SequencingState target_maintenance_state() const { return static_cast<SequencingState>(GetField<int16_t>(VT_TARGET_MAINTENANCE_STATE, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MAINTENANCE_ID) &&
           VerifyField<int16_t>(verifier, VT_TARGET_MAINTENANCE_STATE) &&
           verifier.EndTable();
  }
};

struct SequencerMaintenanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maintenance_id(uint64_t maintenance_id) { fbb_.AddElement<uint64_t>(SequencerMaintenance::VT_MAINTENANCE_ID, maintenance_id, 0); }
  void add_target_maintenance_state(SequencingState target_maintenance_state) { fbb_.AddElement<int16_t>(SequencerMaintenance::VT_TARGET_MAINTENANCE_STATE, static_cast<int16_t>(target_maintenance_state), 0); }
  SequencerMaintenanceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SequencerMaintenanceBuilder &operator=(const SequencerMaintenanceBuilder &);
  flatbuffers::Offset<SequencerMaintenance> Finish() {
    auto o = flatbuffers::Offset<SequencerMaintenance>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<SequencerMaintenance> CreateSequencerMaintenance(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t maintenance_id = 0,
    SequencingState target_maintenance_state = SequencingState::UNKNOWN) {
  SequencerMaintenanceBuilder builder_(_fbb);
  builder_.add_maintenance_id(maintenance_id);
  builder_.add_target_maintenance_state(target_maintenance_state);
  return builder_.Finish();
}

struct ShardMaintenance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINTENANCE_ID = 4,
    VT_TARGET_MAINTENANCE_STATE = 6
  };
  uint64_t maintenance_id() const { return GetField<uint64_t>(VT_MAINTENANCE_ID, 0); }
  ShardOperationalState target_maintenance_state() const { return static_cast<ShardOperationalState>(GetField<int16_t>(VT_TARGET_MAINTENANCE_STATE, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MAINTENANCE_ID) &&
           VerifyField<int16_t>(verifier, VT_TARGET_MAINTENANCE_STATE) &&
           verifier.EndTable();
  }
};

struct ShardMaintenanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maintenance_id(uint64_t maintenance_id) { fbb_.AddElement<uint64_t>(ShardMaintenance::VT_MAINTENANCE_ID, maintenance_id, 0); }
  void add_target_maintenance_state(ShardOperationalState target_maintenance_state) { fbb_.AddElement<int16_t>(ShardMaintenance::VT_TARGET_MAINTENANCE_STATE, static_cast<int16_t>(target_maintenance_state), 0); }
  ShardMaintenanceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ShardMaintenanceBuilder &operator=(const ShardMaintenanceBuilder &);
  flatbuffers::Offset<ShardMaintenance> Finish() {
    auto o = flatbuffers::Offset<ShardMaintenance>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ShardMaintenance> CreateShardMaintenance(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t maintenance_id = 0,
    ShardOperationalState target_maintenance_state = ShardOperationalState::UNKNOWN) {
  ShardMaintenanceBuilder builder_(_fbb);
  builder_.add_maintenance_id(maintenance_id);
  builder_.add_target_maintenance_state(target_maintenance_state);
  return builder_.Finish();
}

struct SequencerState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE_IDX = 4,
    VT_PENDING_MAINTENANCES = 6
  };
  uint64_t node_idx() const { return GetField<uint64_t>(VT_NODE_IDX, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<SequencerMaintenance>> *pending_maintenances() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SequencerMaintenance>> *>(VT_PENDING_MAINTENANCES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NODE_IDX) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PENDING_MAINTENANCES) &&
           verifier.Verify(pending_maintenances()) &&
           verifier.VerifyVectorOfTables(pending_maintenances()) &&
           verifier.EndTable();
  }
};

struct SequencerStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_idx(uint64_t node_idx) { fbb_.AddElement<uint64_t>(SequencerState::VT_NODE_IDX, node_idx, 0); }
  void add_pending_maintenances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SequencerMaintenance>>> pending_maintenances) { fbb_.AddOffset(SequencerState::VT_PENDING_MAINTENANCES, pending_maintenances); }
  SequencerStateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SequencerStateBuilder &operator=(const SequencerStateBuilder &);
  flatbuffers::Offset<SequencerState> Finish() {
    auto o = flatbuffers::Offset<SequencerState>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<SequencerState> CreateSequencerState(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t node_idx = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SequencerMaintenance>>> pending_maintenances = 0) {
  SequencerStateBuilder builder_(_fbb);
  builder_.add_node_idx(node_idx);
  builder_.add_pending_maintenances(pending_maintenances);
  return builder_.Finish();
}

inline flatbuffers::Offset<SequencerState> CreateSequencerStateDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t node_idx = 0,
    const std::vector<flatbuffers::Offset<SequencerMaintenance>> *pending_maintenances = nullptr) {
  return CreateSequencerState(_fbb, node_idx, pending_maintenances ? _fbb.CreateVector<flatbuffers::Offset<SequencerMaintenance>>(*pending_maintenances) : 0);
}

struct ShardState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHARD_ID = 4,
    VT_PENDING_MAINTENANCES = 6
  };
  uint64_t shard_id() const { return GetField<uint64_t>(VT_SHARD_ID, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<ShardMaintenance>> *pending_maintenances() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShardMaintenance>> *>(VT_PENDING_MAINTENANCES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SHARD_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PENDING_MAINTENANCES) &&
           verifier.Verify(pending_maintenances()) &&
           verifier.VerifyVectorOfTables(pending_maintenances()) &&
           verifier.EndTable();
  }
};

struct ShardStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shard_id(uint64_t shard_id) { fbb_.AddElement<uint64_t>(ShardState::VT_SHARD_ID, shard_id, 0); }
  void add_pending_maintenances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShardMaintenance>>> pending_maintenances) { fbb_.AddOffset(ShardState::VT_PENDING_MAINTENANCES, pending_maintenances); }
  ShardStateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ShardStateBuilder &operator=(const ShardStateBuilder &);
  flatbuffers::Offset<ShardState> Finish() {
    auto o = flatbuffers::Offset<ShardState>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ShardState> CreateShardState(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t shard_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShardMaintenance>>> pending_maintenances = 0) {
  ShardStateBuilder builder_(_fbb);
  builder_.add_shard_id(shard_id);
  builder_.add_pending_maintenances(pending_maintenances);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShardState> CreateShardStateDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t shard_id = 0,
    const std::vector<flatbuffers::Offset<ShardMaintenance>> *pending_maintenances = nullptr) {
  return CreateShardState(_fbb, shard_id, pending_maintenances ? _fbb.CreateVector<flatbuffers::Offset<ShardMaintenance>>(*pending_maintenances) : 0);
}

struct NodeState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IDX = 4,
    VT_SEQUENCER_STATE = 6,
    VT_SHARDS_STATE = 8
  };
  uint64_t idx() const { return GetField<uint64_t>(VT_IDX, 0); }
  const SequencerState *sequencer_state() const { return GetPointer<const SequencerState *>(VT_SEQUENCER_STATE); }
  const flatbuffers::Vector<flatbuffers::Offset<ShardState>> *shards_state() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShardState>> *>(VT_SHARDS_STATE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IDX) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SEQUENCER_STATE) &&
           verifier.VerifyTable(sequencer_state()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SHARDS_STATE) &&
           verifier.Verify(shards_state()) &&
           verifier.VerifyVectorOfTables(shards_state()) &&
           verifier.EndTable();
  }
};

struct NodeStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx(uint64_t idx) { fbb_.AddElement<uint64_t>(NodeState::VT_IDX, idx, 0); }
  void add_sequencer_state(flatbuffers::Offset<SequencerState> sequencer_state) { fbb_.AddOffset(NodeState::VT_SEQUENCER_STATE, sequencer_state); }
  void add_shards_state(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShardState>>> shards_state) { fbb_.AddOffset(NodeState::VT_SHARDS_STATE, shards_state); }
  NodeStateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeStateBuilder &operator=(const NodeStateBuilder &);
  flatbuffers::Offset<NodeState> Finish() {
    auto o = flatbuffers::Offset<NodeState>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<NodeState> CreateNodeState(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t idx = 0,
    flatbuffers::Offset<SequencerState> sequencer_state = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShardState>>> shards_state = 0) {
  NodeStateBuilder builder_(_fbb);
  builder_.add_idx(idx);
  builder_.add_shards_state(shards_state);
  builder_.add_sequencer_state(sequencer_state);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeState> CreateNodeStateDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t idx = 0,
    flatbuffers::Offset<SequencerState> sequencer_state = 0,
    const std::vector<flatbuffers::Offset<ShardState>> *shards_state = nullptr) {
  return CreateNodeState(_fbb, idx, sequencer_state, shards_state ? _fbb.CreateVector<flatbuffers::Offset<ShardState>>(*shards_state) : 0);
}

struct ClusterState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<NodeState>> *nodes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeState>> *>(VT_NODES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
};

struct ClusterStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeState>>> nodes) { fbb_.AddOffset(ClusterState::VT_NODES, nodes); }
  ClusterStateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ClusterStateBuilder &operator=(const ClusterStateBuilder &);
  flatbuffers::Offset<ClusterState> Finish() {
    auto o = flatbuffers::Offset<ClusterState>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ClusterState> CreateClusterState(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeState>>> nodes = 0) {
  ClusterStateBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClusterState> CreateClusterStateDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<NodeState>> *nodes = nullptr) {
  return CreateClusterState(_fbb, nodes ? _fbb.CreateVector<flatbuffers::Offset<NodeState>>(*nodes) : 0);
}

inline const facebook::logdevice::cluster_maintenance_state::fbuffers::ClusterState *GetClusterState(const void *buf) {
  return flatbuffers::GetRoot<facebook::logdevice::cluster_maintenance_state::fbuffers::ClusterState>(buf);
}

inline bool VerifyClusterStateBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<facebook::logdevice::cluster_maintenance_state::fbuffers::ClusterState>(nullptr);
}

inline void FinishClusterStateBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<facebook::logdevice::cluster_maintenance_state::fbuffers::ClusterState> root) {
  fbb.Finish(root);
}

}  // namespace fbuffers
}  // namespace cluster_maintenance_state
}  // namespace logdevice
}  // namespace facebook

#endif  // FLATBUFFERS_GENERATED_CLUSTERMAINTENANCESTATE_FACEBOOK_LOGDEVICE_CLUSTER_MAINTENANCE_STATE_FBUFFERS_H_
